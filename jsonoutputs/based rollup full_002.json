[
  {
    "speaker": "Rob",
    "content": "Is that what Gwyneth is technically or now?"
  },
  {
    "speaker": "Guest",
    "content": "Um not sure I completely understand the question but I think yes as in the The Gwyneth will be like a will you use booster rollup functionality or like will have it and also like combined with the base rollup yeah"
  },
  {
    "speaker": "Guest",
    "content": "Well I guess the name booster is just it Brecht just came up with that out of the"
  },
  {
    "speaker": "Andy",
    "content": "Yeah I remember that I remember him saying how about out of our list"
  },
  {
    "speaker": "Rob",
    "content": "Okay Okay so so so this is how the the booster design works here for"
  },
  {
    "speaker": "Guest",
    "content": "for that Yeah yeah yeah yeah Uh so coming the new thing here is that um compared to last time is you don't have to deploy like all the smart contracts on L1 uh because that would be kind of like inefficient for certain use cases So that's why there's some some extra like a smart contracts on the L2 side because for example if you for a user if you want to have like a smart wallet then you don't want to deploy that smart wallet to the L1 even though that that's like benefit like benefits of doing that Uh it would be like very expensive to kind of like force users to do this if they actually want something like a specifically for for themselves Uh and they are not really interested in having the functionality available on all the all the booster roll ups Um so yeah it will be possible to just deploy specific contract as well on like a single L2 and then you can just do all your transactions directly to all the L2s uh like normal But yeah for generalized applications like if you want to have like a token smart a token contract or you have like a a real application like Uniswap or whatever you will just still deploy it on the L1 because then you automatically scale your application across all the all the L2s"
  },
  {
    "speaker": "Guest",
    "content": "Um yeah So well I guess all like said it but yeah So this system makes it possible to easily add more scalability to the system so uh don't have to play like star from scratch but yeah horizontal scaling to the max It's almost like sharded To the max I mean So many of these roll up designs that I see these app chains and L2s and like this expansion there's going to be so many and like uh uh uh firm roll ups and all these different types like I I just always come back to being like damn it We we we had the right idea with sharding We just didn't realize that it was not going to be sharding the L1 It was going to be expanding horizontally by adding new state in the form of roll ups you know Yeah yeah yeah Yeah yeah yeah It's sharding uh except uh in this case you do have like a shared kind of like storage room and and and in the form of like the L1 So being able to just not have like all the states as started but like having like this kind of like already like very well uh But all the interesting data is mostly still on the L1 Uh so having that available next to kind of like your own uh storage Yeah I think it's kind of like a thing think that make a lot of sense"
  },
  {
    "speaker": "Guest",
    "content": "Okay so I will go over like the details of what we actually mean cuz I feel like Brecht's explanation kind of goes everywhere So like um let's start with like the semantics of cross chain reading right So currently on the left hand side you see this miracle proof thing It's basically how we uh read the L1 state or L2 state on these days or today right Um if we want to prove to a chain where Alice has like $10 and uh in L1 or Alice honestly deposit $10 in the bridge contract we would we provide this miracle proof And that is like super asynchronous That's like not asynchronous composability at all But like by saying that we add T E or ZK proof to the paradigm it literally just means that like we rerun the whole execution of L1 or L2 um of this like bridge smart contract on a node that has T E or ZK support right So by the time where the execution is done where Alice has deposit $10 uh in the bridge contract we would have generate a real-time proof um to the target chain So that basically what we're doing is to prove the integrity of Alice deposit so that she can mint on L2 Um so the purpose of both sides of the diagram is are the same It's just that currently um the proof is being being offered as a miracle proof which is also asynchronous Like the proof is being supplied at the rollup time Um but now what we're trying to do is run everything within the same execution uh process So that like the proof is being seen in real time where you know like a a two an L1 and L2 node that are being run side by side can just like synchronously uh compose with each other Yeah So this is for a read This for uh cross chain reading for cross chain writing on the other hand So let's say we have a uh Uniswap deploy on layer two Currently what people are doing is at the rollup operation where you update the rollup state where you're actually updating is the state that are derived from the the state root of the rollup So let's say this uh Uniswap smart contract is on Arbitrum And when Arbitrum wrote up to L1 the state root got gets updated So implicitly is so it also update the Uniswap pool status um on Arbitrum through you know a state right to to layer one Um Arbitrum state root However we're trying to do right now on the right hand side is that when we're actually executing L2 transaction which encapsulate an L1 call to the L1 Arbitrum smart contract we will wrote up the execution result of that call directly on L1 So by saying that we solve fragment fragmented liquidity is the fact that you actually only have one Uniswap There's no like two two Uniswap on L1 and L2 There's only one Uniswap existing existing on L1 and then you so kind of just directly modify the state uh by a delegate call like a direct call to the Arbitr uh to the Uniswap contract as long as it inherit the booster rollup interface Um so yeah um and the uh the call that are being initiated from L2 is is like uh sort of enumerated at L2 execution in advance And then by carrying out this enumeration on OT or some other like real-time proving solution you also like generate the proof for that So when you roll that up to L1 and your L1 smart contract execute a delegate call to the to the real Uniswap contract the proof is also being verified So this is what we mean by actual synchronous composability And Cecilia if I have uh like a Uniswap instance on Arbitrum Optimism and base Yeah Then all of those end up getting aggregated be when they get when they get put when they change the state on the L1 and that's how the liquidity is is synchronous and it's composable across those three environments because you end up aggregating it when you change the L1 state Uh yes So you guys still have your swap separately deploy on all of these chains right It's just is a implementation choice Like you can swap can be like I only want one instance of my contract being deploy on the main chain and then this this uh contract inherit the booster rollup interface where you know for any sub chain that carry out the execution of the Uniswap smart contract with the proof um can you know modify the state of the L1 Uniswap contract directly as long as the proofs are verified So you're basically using L2 block space to execute L1 logic And updating the L1 and result at rollup time And then And then the L1 is like a proof aggregator Yeah Yeah Um I would think that as a proof verifier right Or that the proofs can be aggregated at the same time right If you have that many proofs Um basically each there's still like detail uh regarding the block building So you you have to have like exclusive like write lock on the contract state of of Uniswap And that will be like implementation details that we may or may not have time time to go over So Hopefully Hopefully Yeah go ahead It's also it's also important that uh like you don't have to touch the L1 state if you don't have to right So if you don't want it so it's kind of like up to the application to decide like how uh how it's most most efficient to kind of like split up the state So you can have like a Uniswap pool on the L2 and you can actually write the state there directly It would just be not directly shared between all the all the other L2s and the L1 that's"
  },
  {
    "speaker": "Rob",
    "content": "Cool We'll uh we'll try to stop interrupting you guys so that we can get to the block building part"
  },
  {
    "speaker": "Guest",
    "content": "Sure sure Um so Brecht is going to go over this simple example Okay But people are interested in block building for some reason Okay so I'll keep it short So the so we yeah this kind of an easy kind of example like how it actually would work So for example if the user has like a smart wallet on on the L1 then this could contain like all the social recovery state there Uh but then yeah this would just be like data there Uh and then on on L2 you would actually execute like a a a smart wallet transaction This would be able to check like all the data that's on L1 to be able to say like okay I need like these two addresses to sign stuff Uh you would just be able to call like the L1 contract to kind of like verify which signatures are required And then the smart wallet on like the left L2 would also be able to"
  }
]