[
  {
    "speaker": "Rob",
    "content": "EigenLayer provides the foundation as your restaking platform. Then of course, you have different uh, forms of economic security. You have natively staked ETH, you have uh, liquid re-staking, and then you even have other token projects. Right? You have stable coin projects that might say hey, look we want our economic security to be used. The great part here is you can actually, as an application, when you're thinking about our community and you're saying hey, look what is the source of policy enforcement that we want, the pre-transaction check, who are the ones who are enforcing this, you can start with a wide network of operators and say whoever issues signatures first based off of a quorum that we've set, they come first. Or, you can even set uh, an alignment with specific operators. You can say look, maybe I really want, uh, P2P in this or I really really want Figment or, and a project and a community might say hey, we actually want our token to be used on the backend because it's alignment for this policy enforcement. And so, we want operators who have specifically our token as well as part of economic security. This is something, for example, that M0 might want. M0 has a network in which you're saying how do we create a a mechanism for minting stable coins and have a network of validators. So in this case you can actually align thats the, the validator network, to the minting of stable coins by also utilizing their their core asset as part of it. But that flexibility can become really powerful when you're starting to think about what is a use case that you want and what are certain things that you might actually want in place. "
  },
  {
    "speaker": "Rob",
    "content": "And that leaves here. Let's take an intent system. This is a different use case, but again this expressivity becomes really valuable when we think of an operator network. Uh, traditionally an intents, uh, the user right now you know, such as myself, express the outcome that we want of the transaction. Usually, it's like something like I want best price for this swap. That's the most common I think of that is like V0 of intents. But over time you're going to have more complex types of intents. And really at the end of the day, I should be able to have expressivity in terms of how are my intents executed, because I might actually care about that. I might care that my transaction goes through a route that's not been exploited in the last six months, because I'm saying hey, look I'm moving a larger amount of funds. And, you know, I've done that before, in the sense of like I'm like am I going to, which front end interface do I use for certain swaps, it's because I'm like you know, I'd rather use a Uniswap labs interface versus something I don't know, because I'm like maybe this time around I'm willing to pay the fee, right? There's certain things that I really care about here. And we should envision the same for intent systems. So now, in an intent system, you express your preferences. So here it's, in this case with this uh, diagram, I want to express an intent that I get, I do a swap of DGEN on base for ETH on Ethereum, but I don't want it to go through any routes that have been exploited within the last six months. So, I've expressed that preference. From there, now that transaction needs to be broadcasted to a middleware that is then broadcasted to an operator network. The operator network, again, brings in the relevant external information to say hey, these are the routes that in which a transaction, or, here, these are the routes in which you can execute the transaction while meeting this uh, the specification. The operators do a compute. And then, give the outcome, and then the uh, the transaction is executed through solvers in a traditional intent system. But going to here, where I was talking about, you can actually start specifying what types of operators. This gets valuable, right? Because now suddenly, if I have a generalized intent system and I'm trying to set specific operators, or I'm trying to set specific routes, you also can have specific operators where the ones who are fulfilling the the checks based off of what assets they're holding. You can specify I want specific operators or I want operators who are holding certain collateral, uh, for economic security, because they are now the ones who are incentivized to do this correctly. You're able to start doing an entire spectrum of speci- specifications. Again, without, again, trying to do this in a more generalized network. If you were to do this like, without something like EigenLayer, it becomes infinitely more, uh, complex and more difficult."
  },
  {
    "speaker": "Rob",
    "content": "So it's all about the ways of how you can use EigenLayer to align, um, your economic security and your compute in your pre-transaction checks."
  },
  {
    "speaker": "Rob",
    "content": "And really what that enables is a more sovereign and express-, expressive transaction paradigm all while retaining decentralization. That's fundamentally never been done. We've seen some of these types of executions in web2, in traditional fintech rails, where you rely on centralized intermedi-, intermediaries to process, validate transactions. But having it in a trust-minimized, decentralized manner to be able to execute all these things is something that is only possible, is, is only possible on web3, and only possible when you use something like EigenLayer."
  },
  {
    "speaker": "Rob",
    "content": "So that's really kind of how we envision the world and where EigenLayer is really powerful when we think of the ability of transaction prerequisites. So, I'll pause there, thanks a bunch."
  },
  {
    "speaker": "Andy",
    "content": "That was phenomenal. Uh, yeah, great I, I do have, uh, several questions here. So, uh, let's uh, let's get into it. First of all that, that was great. I love how general the system is, um, and, and, you know, using the EigenLayer operator set, the, the Ethereum operator set through EigenLayer for, for quite a robust set of uh, potential use cases. I want to hop back of, um, to, I guess, let's hop back to the intent example first, because I, I actually I wrote it down in my notes as intent preferences back in slide like eight, and this is slide 14 and then you ended up getting there. So."
  },
  {
    "speaker": "Rob",
    "content": "Oh, cool."
  },
  {
    "speaker": "Andy",
    "content": "Yeah, so I, I think this was like automatically just, uh, uh, uh, really, um, just a strikingly obvious use case for, for this system. As we see intents get more and more prevalent, um, like you said, right now, the, the main lever that people try to pull is best, best execution price. And then, maybe they'll, they'll slide the latency lever you know, back, right? If they don't really care how, how quickly they get filled but they really want the best price. Can imagine you know, bigger transactions, bigger institutions, using that, that sort of uh, tradeoff. Um, and, and, you know, we can also pull different kinds of levers. We've had several conversations with, uh, Arjun from Everclear about the way that these solvers tend to rebalance positions. And so, it's not just the intent, uh, uh, submitter, the person who's trying to submit the transaction, but it's also the solvers that are rebalancing their, their inventory. And maybe, um, you know, you don't really care if you're transac-, you want the ETH, right? And this example you want to get rid of DGEN and you want the ETH. But maybe you don't care if it's ETH on Ethereum or Optimism or Arbitrum. You can kind of create this set of trusted rollups. As long as it's on one of those you know, you, you would be fine with the outcome, and then choose the best parameters for that best price. Is maybe Optimism uh, so you go to, you take the ETH on Optimism, right? And you could And, and what you're saying is you can check those predic-, those, those, uh, the state of the solvers, um, basically price quotes and, and latency quotes, you can check that ahead of time, and then submit the transaction for the ideal path."
  },
  {
    "speaker": "Rob",
    "content": "That's right. So, it, it depends on how you do the flow here, but that's right. So generally speaking, that's right. So you have a network of-, you have solvers, right? And solvers are responsible for constructing the transaction pathway. And so then what they'll need to do is say hey, we're constructing the transaction pathway. What we'll have to do is we should check, we need a-, we need a, we need a validation, we need a check, saying that yeah, this meets a requirement. And so, as they're doing that, they're able to basically broadcast to the operators. And the operators are pulling the relevant information needed to say, yes, yes, no this one isn't good. Yes, this one's good. No, this one isn't good. Uh, so that way you have that ability to express. Because otherwise, if you try to have all that done by a solver, it starts becoming more and more computationally heavy. You lose, you're going to lose the expressivity, you're going to have, you're going to have challenges around latency. And so, instead, I subscribe with the view of solver specialization over time. And so in this case you're actually plugging in your operator network with solvers. So there's actually, and I want to add, there's like, you know, there's actually another vantage point here too. So here, we've talking about the user expressing um, preferences for their execution. You can also have, presumably, solvers will likely have special-, preferences for how transactions are executed, and which ones they do. And liquidity providers in the solvers will may also have preferences for how their liquidity is used. That becomes really interesting, because when you start going to the world of solver marketplaces, like what a group like Kalan is doing, um, you'll probably have LPs who are saying here's how I want my liquidity used or here's certain cases in which I don't want it to be. But how do they actually have the ability to express that? You still need a mechanism to do that. So in this case what we're able to do is we can, you know, you can, it's relevant for user expression for executions, but it's also relevant for the solvers or the LPs of solvers, or any other participants who are saying hey, we have specific requirements for how this transaction is executed."
  },
  {
    "speaker": "Andy",
    "content": "Yeah. Yeah, didn't, didn't think about the LP use case there. That, that's really cool, and very, very excited about what Kevin is doing at, at Kalan with solver coordination. Um, awesome. Okay, that, that makes a ton of sense, and I think it, this, this solution is very powerful for, for intents. Um, originally I, I, it came to mind because the predicate here, like I, when I was going through English class, I always learned like you know, subject and a predicate, is makes a complete sentence. And so, you know, when I'm, when I'm thinking here, and I see that these are predicates right, what is the subject? Intents I think fit very very nicely, uh, in that framework."
  },
  {
    "speaker": "Rob",
    "content": "Yep."
  },
  {
    "speaker": "Andy",
    "content": "Um, I want to uh, dive a little bit deeper into the architecture here. Um, so I think we'll, we'll cycle back a couple of slides, to, to here. And so, I see the-"
  }
]