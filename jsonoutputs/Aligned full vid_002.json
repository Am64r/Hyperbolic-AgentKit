[
  {
    "speaker": "Rob",
    "content": "Who would pay like, um, $6 to hide or $10 to hide, uh, information on the transaction of, uh, my purchase of a coffee or something? So, um, what we see is that verification costs remain high and that if we could reduce, uh, them, then, of course, we could begin unlocking, uh, several new applications. Besides, this is one of the main, uh, operational costs rollups have. If you, if you take a look just in verification costs, rollups can have over a million dollars per year. And that, of course, limits the, the, the prices they can, they can offer for, for example, transactions. So, targeting, uh, proof verification is, um, very important to help Ethereum scale. Okay? Because then we can process maybe more proofs, uh, onboard more users, offer lower costs. And also, like, start developing new, new applications."
  },
  {
    "speaker": "Andy",
    "content": "So, here are like some of the factors we, we mentioned. Of course, um, to adopt CK, uh, one of them obviously is related to proof generation. Okay? Uh, in the last year or so, we've seen like many new tools that, um, help us write, uh, provable applications more easily and, um, and faster, okay? But in general, the problem with proof generation was that in, in the beginning, you had to understand a lot of the details of, of CK, you had to write, this, what, arithmetic circuits, okay? So, it was more or less like you want to code your application, but you have to do it in assembly language. Okay? You can do it, but it's going to be, uh, very painful, back prone. And then you also had like very limited expressivity, the kind of things you could do was pretty limited. And then we have the other like half of the problem, which is verification. You have very high costs, these, um, the verification tasks compete with other applications on top of Ethereum. You have like low throughput. Okay? So, if we want CK to be used on, on a massive scale, then we have to solve these two problems. The first one, okay, I think it is solved with zkVMs, prover networks, and hardware acceleration. Okay? So, the idea is right now you can write, uh, code normally, for example, in Rust, feed it, feed it to some of these VMs and the VMs handle all the problem of proof generation. They are getting better and better. We have like some new exciting developments related to, for example, Venus or Circle Starks. So, we've seen that, for example, it is possible with Circle Starks in, uh, Mac and 3 to prove like 600k hashes per second, which is like a lot. That's more like, uh, over like two orders of magnitude more than, uh, what we could do before these new proof systems. Um, and then, of course, prover networks, um, give us the, the chance to offload proof generation which, which can still be, uh, computationally expensive, um, to other parties and there will be like some competition and then we can get like, uh, lower prices and, of course, then we have like new tools related to hardware acceleration. So, uh, I think that we will see like consistent, uh, improvements in, in proving. And so, then we have to look at the other half which is, um, proof verification. And there, we have like two options. One is this idea of, um, proof recursion, okay? The basic idea here is, uh, remember that I can prove, let's say any kind of problem, uh, program. One, one program I could prove is, for example, that I verified a proof, or that I verified two proofs. So, what I would be doing then is taking two proofs, their public input, feeding them to my prover, and generating a proof that says that I verified those two proofs and the two proofs were valid. So, now, if I verify these new proof, this is exactly as if I had verified the two older proofs. So, what I do is kind of bundle a collection of proofs into a single one, and then I post that to the, the L1, and the L1 just verifies one proof. Uh, but that proof is equivalent to maybe, I don't know, a thousand proofs. And so, the verification cost get split, uh, among the, the different proofs. And the other option, of course, would be to build a dedicated, uh, blockchain for proof verification. Okay? So, this would be like your two options. Either you move verification off-chain to another chain that will only handle proof verification or you use this, um, proof recursion."
  },
  {
    "speaker": "Guest",
    "content": "And, or, or you could do both, right? You could, you could bundle and submit to a separate blockchain. And then you can, and, and the proofs that you submit to the separate blockchain, you could bundle up a bunch of proofs together, and then verify all of those at once. And so, I think you mentioned, you know, growth 16 was like $6. Um, you could amortize the $6 across maybe thousands. How many, you know, just, if you know off the top of your head, do you know how many proofs you could bundle together? Is it, "
  },
  {
    "speaker": "Rob",
    "content": "Well, right now, uh, and this is one of the problems you have with, with proof recursion, you have, remember that you have to prove that you verified like two proofs. And, uh, even though verification is very fast, proving verification is rather expensive because we have to prove all the operations involved in the verification, which, for example, can, can involve, um, hash functions and so we have to represent, um, I don't know, the Keccak hash function, which is not that easy to, to arithmetize or it's like more costly than just running Keccak, uh, normally. Or you have to do some things like, uh, field emulation if you are using elliptic curves. So, of course, there are like some of these, uh, let's call them aggregation layers. That what they do is they do proof recursion. Um, but the problem is you, you cannot add like many proofs together because you have to prove that you verified proofs, okay? So, uh, I've seen some examples that maybe they can do 30, 50, but the more proofs you add, uh, the slower it gets. And so, what you are doing is kind of trading cost for latency. Okay? You say, okay, I'll have to wait more, but then I can reduce costs. And so, you have something where, of course, you, you, you reduce costs, but maybe your application needs low latency. And so, how can you do that? Uh, there is like an, an optimum, but the problem is you see that for some applications then that you need low latency, you're going to get higher costs. And, if you get like lower, uh, uh, low latency and higher costs, so"
  },
  {
    "speaker": "Guest",
    "content": "We, there's a trade off. We're, crypto people are very picky. We want both. We want both. We want it to be cheap and fast, and secure."
  },
  {
    "speaker": "Rob",
    "content": "Yeah. Everything and, that's the problem we, we always face in blockchains. You, you can't always have everything. But we can come like pretty close to that if we accept like some basic changes or a, a little trade-off somewhere else. So, as I was telling you, you have this problem, okay, proof recursion. Uh, you add latency, but you reduce costs, it may be useful for some, I don't know, rollups do this. What rollups do is, for example, you want to prove the transactions in a block and instead of like proving the whole block, you prove each, each, each transaction separately and then you use this idea to combine the, the proofs of two transactions into one. And so, what you do is like a binary tree of proofs, and you get one final proof which is basically the proof of the block. Okay? Uh, so, that's one of the ideas. With the verification layer, of course, then we are free to build, uh, our, um, own blockchain, we, like, remove all the constraints from the EVM, we have like more design options, we, we can verify proofs like natively. But then, we face like other problems. We have to bootstrap the economic security of the network, we have"
  }
]