[
  {
    "speaker": "Andy",
    "content": "these providers in the space to be able to kind of hold on to the long-term data that is provided from these providers and these blockchains state. This is where Covalent comes in. They just had a nice rebrand check them out on Twitter as well as the website. Thank you for being here. Hope you enjoy the rest of the show."
  },
  {
    "speaker": "Guest 1",
    "content": "I, I was about to touch on that 'cause I have many slides but we Sorry, sorry I'm going to stop here. <noise>"
  },
  {
    "speaker": "Guest 1",
    "content": "Uh, but it's okay but literally what you just mentioned is literally this situation that we're talking, that I will be touching on. So I'll just jump ahead. Um, so if we imagine we have like multiple layer twos, right? We have this like pink layer two and the blue layer two, where the builder um, choose to, to be the sequencer of both of these layer two. Actually that, the paradigm still work, right? Because you basically do the same thing for the other layer two where um, your the, the transaction of different chain can actually synchronously compose, compose with each other. 'Cause like they're, they're basically in the same mempool, right? And if we have like atomic transaction where, you know, like a bundle can goes across the pink layer two, the blue layer two and the gray layer one. Um, they can like literally be, uh, packaged with each other through, you know, the uh, um the building paradigm that we're going to introduce um, yeah. So like, so, and also like, different protocol, the protocol design is still like open for, for different layer two, right? And we can have the, the pink layer two settling execution ticket. And we can also have the blue layer two having a you know deterministic look ahead through AWS. Um, so this system is like totally flexible. You can do whatever. As long as, the states are, available for the builder to build. And the builder can also um, choose to exclude, um, the layer two that he doesn't want a sequence for. Like the builder can just say like I only have access to the pink layer two or I don't want the blue layer two or I just want to stand for the blue layer two, whatever. Right, you, as long as you have the right RPC endpoint and you have the access to the mempool, the order flows, whatever, you can build for whatever you want. And I think this really introduced like a new MEV, um,  MEV market where builder can really do like cross chain atomic MEV in this paradigm. Um, Yeah. Yeah just wanted also mention that like uh we do have to be careful about like uh adding like extra barriers to kind like be able to synchronously compose between the L2s because yeah, that's kinda like the main, the main selling point is that it should be like easy and it should be like just like work out of the box. So if you have like multiple kind like uh, uh, leader selection or like multiple like execution tickets for like the different L2s. Then, it's great for value capture, but we have to be, be also like be aware that this could actually, increase like barriers and becoming a builder and also like decreasing like the chance that if you do like a cross chain transaction, that will be picked up by a builder that actually has the correct access rights to, to the, these different chains. Um, so yeah, there's like a, an interesting kind of like balance uh going on there with uh you can, well you probably can't go like max value capture uh because you still want to have like the good user experience as well. <noise>"
  },
  {
    "speaker": "Guest 1",
    "content": "Right. Since we're talking about like bundle and MEV. I'll just jump ahead to like here, right? Like, an example of like, how these um, cross chain bundle will actually be executed will be something like this. Where you have like for example, a user will wanna bridge uh, ease from L1 to L2 and swap on L2, and then bridge it back to L1. And let's say these are all atomic. They're supposed to execute together, right? So like within the builder's database like uh, you will virtually see these bundles together. And then, um, at the road up point, right? You will have to like, um, like he will have to wrote up the transaction into L1 block, with like this, this the first transaction being on L1 and the second transaction on L2. The third transaction on L1 again. Um, and then you, and, and oh yeah. And this kind of like, this implies that the builder has to have exclusive sequencing right of, the L1 block and the L2 block because like, the the order have to be preserved. Um, this is where pre-confirmation comes into place, right? If the builder doesn't have the right, through pre-confirmation, if there's isn't like a, a pre-, pre-confirmation provider that let the, the builder to execute, to, to become like uh, to guarantee the voter for, execution pre-comp, then this thing wouldn't be possible. That's why, pre-confirmation is also very, very important for us. Um, however though, like if you only care about like, L2 order. Like if the, the transaction itself doesn't, doesn't, doesn't go through L1, in a strictly orderly matter, then you don't have to have execution pre-confirmation. Like inclusion pre-confirmation will be enough. If you, if you just want to wrote up the state of L2. However, if you want to introduce any, synchronously compo-, any composability actually, from L1 to L2, the fact that like the L2 execution depends on certain state of L1, then you, you do, you do need like execution pre-confirmation. Yeah. So that's that. Um, and in fact if we, if we wanna go into like more detail into how these transactions are formatted. So this is our design, right? Um, I like bundled these three transaction like this 'cause it's like easy for people to understand. But in fact for a user, you only need to like send one transaction, that are, being packed like a onions, that look like this. So a, the user since this transaction is originated from L1 right? 'Cause you bridge from L1 to L2, right? Um, the outer skin of this onion will be like L1 transaction, in which, the inner transaction will be encapsulated as, you know, call data and, and being picked up by the, by the L2, L2 process within the, you know, the base builder big node, the node that sequence for both L1 and L2, right? After the L1 is being processed from the, the um, from the L1 execution like, it will like call the L2 node right? And sends the inner, inner parts of the onions. And the L2 node get executed, which encapsulate another L1 call, within itself that are being emulated in the L2 EVM. Right? So at the wrote up time, where we have to like, roll up the the end state to the L1, we'll actually, it will actually contains like two process right? Like the L2 thing, the L-, the L2, the pink layer will actually be rolled down, in the L2 execution context. But um, the L1 processes will be wrote up. Right. to as the end state of the L1. And everything has to be carried out in TEE or ZK. Because, you can't just like, insert miracle proof randomly in these processes. Right? Like if everything is directly proven in real time, um, like the execution integrity is guaranteed, then you can basically like wrote up and wrote down freely, at any time, in however way that you want to compose your transaction. Yeah. Yeah. So  This is and it's like embedded, right? Like we have transactions that are embedded into one another. My question here is like you know, everyone who's around and like using, like AAVE and Uniswap and Compound and like the popular applications you know, they had liquidity on L1, but now everyone has migrated their liquidity and their assets and they're doing things on L2. It sounds like here, you know, L2s are still used for execution, but it's almost like we're going to like bridge to the L2, we're going to do some execution and then we're going to come back to the L1. Do you think people are going to migrate liquidity back to L1 and then start to like use like L1 and make transactions and hold their, their assets on L1 and then use this to like make transactions on L2 and then get it back on L1 or, now that all the liquidity's away from L1, you think it's just going to stay on L2s? Yeah.  Um, I think this a good question. 'Cause like I said, right? We're using L2 block space, as, an execution layer of L1. So like L2 is literally an execution extension of L1. Uh-huh. And also since L1 has the max-, maximum amount of, you know, security guarantee, so it kind of make sense, to keep your assets on L1, right? And just leverage because like, by the end of the day all these L2 nodes are just, uh, extra execution power. Mhm. Like, execution capacity that you add on to like, the base chain. Like, the base L1 chain right? Um, so I think like after this, this ecosystem being picked up. maybe you will see more people migrating their assets, back to L1. Mhm. And only use L2 as, as you know, an execution layer. And then the L2 builder, will, will get revenue from like processing your, your, your execution. Yeah so I think it's also like the, the, very, like, depending on like, well, kinda like the priorities, right? So if you are like, very like, security uh, sensitive, p- <noise>"
  }
]