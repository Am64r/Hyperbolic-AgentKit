[
  {
    "speaker": "Rob",
    "content": "Some higher level language, for example, it can be Cairo or it can be Rust. Then, the idea is that code gets executed on a virtual machine and what it's going to output is, for example, the trace and the memory of the execution, okay? Then you have to do like some preprocessing, you have to do some conversion or encode all that information using polynomials. And then you have a series of steps that depends entirely on the protocol, but as you can see the prover has to do a lot of work and whether it's easier or harder depends a lot on the kind of technology you are using and some of the primitives that you add for example, different hash functions can lead to uh dramatic changes in in performance. And finally, after all these steps what you get is a very short string that then you can check it by by doing some very simple computations. Okay?"
  },
  {
    "speaker": "Andy",
    "content": "So then once you get the proof, what you have to do is verify it and that is what, for example, the nodes are going to do. And then, for example, what you do is you check that the proof is well formed, that it contains like the type of elements you need and the length it’s supposed to have. You have to also check all the public inputs, okay? Check that um, they used for example, the right initial values and that the output is, is correct. You may have to, for example, recover some verification parameters like a verification key or some information on the program you’re running. For example, it can be the hash of the program or even the, the program’s uh code. And after that, what you do is you run the verification algorithm, which is more or less like the previous case, maybe you have to compute some functions and then do some basic checks, and the good thing is that verification, in general, is very fast. Okay? It can be in the order of milliseconds or even less. And no matter if your computation was like super complicated or super hard to prove, the verifier has to do a lot less work than the, the prover."
  },
  {
    "speaker": "Andy",
    "content": "So let’s see what happens when we want to verify these proofs in, in, in Ethereum because what we want is to, again, move the execution outside of Ethereum, for example, to a rollup. Then the rollup kind of submits um, the state diff and the proof showing that uh, it is valid. And, then each of the nodes in Ethereum reexecutes the computations. They all reach consensus on the validity and then they can update um, the state."
  },
  {
    "speaker": "Rob",
    "content": "Good question, theoretically, does the, does the execution move off of Ethereum L1 onto a rollup? Could, or could, could Ethereum L1 just execute once and verify and submit a proof and then verify amongst its nodes and arrive at a consensus that way?"
  },
  {
    "speaker": "Andy",
    "content": "Yeah. I think that, that, that you can, for example the one proposing uh, the block or something can generate the proof and then the rest just have to verify because the, the proof what it does is uh, it replaces re-execution."
  },
  {
    "speaker": "Rob",
    "content": "Mhm."
  },
  {
    "speaker": "Andy",
    "content": "I can give you, I, I can say like, okay, I’m going to take all that heavy burden from you, you get this very short cryptographic string and then you can run it and it is the same as if you had uh, reexecuted uh, the computation. So, it’s, it’s very promising because then you can uh, remove all these instances of re-execution to just re-execution of the verification."
  },
  {
    "speaker": "Rob",
    "content": "Which is much, much cheaper and I think you’re going to get into uh, the gas efficiency uh, for proof verification here."
  },
  {
    "speaker": "Andy",
    "content": "Yeah. So, when, when we want to verify in Ethereum, we find like, we have like some constraints. First, we cannot exceed the maximum gas that we have per block, and that, of course, limits the amount of proofs that, that we have. Then, we don’t have parallelization, which is something that we could, would love to have. For example, then if we get like millions of proofs from different like rollups or applications or whatever, and we want to verify them, if we can parallelize they are like easy tasks and, and we can process like maybe millions or at least hun-, thousands of transactions per a second. Then, we don’t have like any kind of hardware acceleration or anything we cannot leverage GPUs or whatever because, again, the, the upper capacity is bounded by the gas per block. Then, of course, another thing that we have is that we have to optimize the code for verification for gas consumption because that’s the relevant metric here, not speed. Going faster isn’t going to make, more proofs fit into a block. And then, the other problem is that uh, the cost depends on the availability of uh, precompiled contracts. So, there are like some operations that um, cost less because you have this um, precompiles. For example, uh, pairing-based um, proof systems are way cheaper than others because the pairing has like a fixed cost, you know it’s going to take more or less um, one hun- hundred thousand gas or something. At least for the checks you have to do, and so that may be way less than, I don’t know, other things that you have to do for other proof systems. Of course, the, the main problem with this is that then you are limiting the kind of proof systems and primitives that you can use in Ethereum, okay? And that reduces uh, your choices as a developer to choose like the best proof system for your application. So this for example has led many rollups to use a proof system that is very efficient to prove their blocks and everything. But, once they get, the, the proof, then they have to do another transformation, build what we call a recursive proof and generate a new proof in another proof system that can be verified very cheaply in Ethereum, and that typically is some of the pairing-based proof systems. Of course, you are doing that at the expense of like uh, additional costs and additional latency. And also, you are like um, abandoning some of the nice properties that your proof system uh, may have. Okay? So, just to give you an estimate of the cost of uh, proof verification, here I have like some popular um, proof systems, their gas costs, and just to give you like an estimate of the amount it is in US dollars. Of course, that depends on network congestion and then also on the relationship between Ether and, and the US dollar. But, as you can see the cheapest uh, proof system is Groth 16. It costs around 250k gas, which is more or less like $6 per proof. It can be less, more, but it’s more or less that number. Then if you want to use something like Halo 2, it’s nearly double. If you want to use Starks, Starks are really efficient for proving but they are like super expensive in Ethereum. They are like 20 times a Groth 16 proof. Then if you wanted to use for example, Kimchi, which is the proof system you have in Mina, which is like very useful to, to do proof recursion and to have like a very succinct uh, blockchain, it works really well in, in Mina, but in, in Ethereum, it’s super expensive. So if you wanted to verify a Mina proof in Ethereum, it would be like super costly. And then, for example, there are others that we don’t know their costs, for example, Binius or others because, I don’t know, if we try to write down all the verification and all that, the cost might be even higher or even not fit in, into an entire block. So, as you can see, we have like many developments, many excellent ideas in, improving technology, but we cannot uh, use them in Ethereum because we may lack for example, some precompiles or um, simply Ethereum is not adapted to, to this type of, of technologies. So, the thing is can we, can we do better than this? And, um, also we see that the cost, even the cost for Groth 16 is quite high, okay? So, if you wanted to use this and um, you would have to pay a lot of money, for example, for some, some application, we, we have this um story from, from Vitalik saying, p-"
  }
]