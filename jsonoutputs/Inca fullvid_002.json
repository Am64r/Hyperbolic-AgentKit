[
  {
    "speaker": "Guest",
    "content": "logic"
  },
  {
    "speaker": "Guest",
    "content": "on top of encrypted data. So if you know, build like a private AMM, you know, you have to be able to add, multiply, divide, right, to to calculate the the tokens coming out. This reopens up for, I'll say, a lot more design space uh, around this idea of private computes. And, and again, this is all happening through cryptography. Uh, basically, you don't need a specialized hardware for this. Uh, you don't have to write, you know, complex circuits, uh, nor you, you don't need any, you know, option coordination, cuz you don't have this like, prover verifier system. It's all basically happening, um on chain. Uh, and then with FHE, you can also derive, uh, randomness, um, and, and, and this is actually quite useful in the sense that, like, this randomness is actually encrypted by default. So, um, quite useful for, for example, card games, you generally, uh, hidden cards, right? So a little bit different than your typical VRF that's, you know, plain text based. Uh, that for example, Chainlink would, uh, provide."
  },
  {
    "speaker": "Guest",
    "content": "So, you know, FHE has had forty years of history. There are actually a lot of schemes. Uh, so there's TFHE, BFV, BGV, CKKS, and many, many others. Um, I guess this is a little bit more, uh, specific, but yeah, yeah, we utilized the TFHE scheme. Uh, there are a couple benefits of this. Um, just broadly, you know, TFHE does support, uh, a lot of operations. So, uh, additions, multiplications, divisions, comparisons, uh, pretty broadly. Other schemes sometimes are, you know, constraint to, uh, only additions and multiplications. Uh, but they could be more, more, spec, spec, specialized for other use cases, right? But in the context of smart contract, you want to have the ability to, uh, have a wider range of, uh, way to express yourself, right? You need to be able to do, uh, more complex operations. Uh, the other schemes, you could, some of them, you know, uh, um, you, you could, you could have them do, uh, additional operations, but oftentimes they become approximations. So, they, they are not going to be appro-, um, accurate. And the reason why this wouldn't quite make sense in the context of smart contract is, you know, imagine DeFi, right? You want the every single operation to be exact. You want exact computation. You can't have a balance that's, you know, slightly off or you can have a, uh, a DeFi pool, uh, that has a liquidation threshold, that's like, you know, slightly off, right? Uh, so, exact computation is also very important. And then, uh, what I mean by non-level structure is, some of these FHE schemes also, you have to predefine ahead of time how many steps, operations you'll be doing. And so, what happens is like, you would do something like, uh, a bunch of operations and then do a big bootstrap at the end of it versus TFHE actually does a bootstrap in between operations. Uh, so more frequently, um, to keep the drop, the, the noise in check. But, uh, what you also get is this amount, uh, basically unlimited depth, uh, of operations, right? So you don't have to necessarily know ahead of time how many operations you need to do. So it also make sense for smart contracts, because, uh, yeah, the, the smart contract logic can be arbitrary, right? So some dApps will have, uh, longer or shorter logic. So, so yeah, this is just, uh, I guess from a high level, uh, introduction to, you know, there are other schemes as well. Some of them could also be more specialized for, you know, AI, machine learning. Some of them are more suitable for smart contracts. So, what we're building, uh, at Inco here is, you know, essentially the, uh, confidential computes, uh, layer for existing blockchains. And, from a high level, you know, we are a layer one blockchain. So, uh, back to that previous, you know, slide that I mentioned, uh, earlier for DustdApp, you can almost think of it similar to Celestia in a way that, like, we are also a layer one blockchain. Uh, obviously Celestia is also a layer one, they provide, uh, DA as a service. But Inco provides basically, uh, confidential compute as a service. And with this we also do support, uh, ciphertexts, uh, because they are quite big. Uh, we also do have our own consensus, uh, so right now we're using Comet BFT, which has the property of, uh, instant finality. Um, I can probably dive a little bit deeper why this is important. Uh, but from a high level, um, you actually want a system that has instant finality, because any rework is problematic in encryption systems. So, it imagine, you know, I decrypt the value, and now it reworks. I cannot unsee that information, right? So, there, there could be information leakage if there is a room for rework. So even within the consensus, uh, you know, there are, uh, obviously other consensus mechanism, like Grandpa and some, and, others, right? What Comet BFT really offers you is instant finality, uh, which is quite convenient. Um, the same goes for, you know, anything that's more optimistic, uh, as well, which is there, there is this, you know, at least seven day window for finality, which is, uh, still risky, right? Uh, any information you decrypt, that information's leaked. Uh, or any information you unwrap, right? So, imagine a confidential balance that you unwrap. It's effectively bridging. So you do want this property of instant finality. Also consequences could be also, uh, quite, quite, quite bad, basically. So, I, I know I talked a lot about FHE this entire time. Uh, but really what we're building here is, uh, is a combination of MPC, ZK, and FHE. So FHE really is, uh, refocused on compute, right? So, anything related to, uh, computation, you do it over FHE. On the client side, this is where the ZK side, uh, we utilize ZK. Uh, you generally ZK proof for two purposes. One is you want to prove that the ciphertext is not malformed. Meaning that, you know, the ciphertext is encrypted under, uh, this defined public key. And then, you know, the formats, everything is correct, else, you know, later on, this will have issues right on the, on the compute side. The second thing you're proving is, as you are encrypting the plain text into the ciphertext, you also generate a ZK proof that you know what the plain text is. And, and this is, uh, I'll say important in Web3 because, you know, you're still, we're still supporting public blockchains. So, it is possible for someone else to, you know, copy paste your ciphertext, and then try to deploy it somewhere else and decrypt it, right? So, so this acts as a gating mechanism. So the only way for you to input ciphertext into the system is to prove that you also know what the plain text is. So this is what the ZK proof also includes. Uh, for decryption, we utilize MPC. So, the benefit of this is that, uh, in MPC essentially the private key never existed. You, typically you would generate this through a distributed key generation system where you know, every single node operator only has a fragment of it, uh, has a keyshare. And so for any decryption, what happens is, every single node does a partial decryption and you need to combine a threshold of all these decryptions to recreate the plain text. So this is sort of, like, you know, high level, how, you know, we guarantee security, uh, across these different components, you know, from the user side, to the compute, to the decryption. Um, it's a very high level here. So, what offer the most intuitive way for people to, uh, write code. So, so first of all, you know, because we're augmenting, uh, EVMs, you get to write these FHE code within the EVM, uh, which should be pretty intuitive for developers. Uh, we also support the ability for FHE compute on top of existing blockchains. So, this is where, you know, you could also tap into the existing user base, uh, but also TVL. Uh, just quickly, uh, from a high level how this works, uh, you know, ciphertexts, they could be, there are actually quite big. So, Inco, uh, we'll be in charge of storing the actual ciphertexts. And what you're storing on Ethereum is essentially the handle. So, you can think of the handle, kind of like the key, right? So, it's like a key value, uh, pair relationship. So you're storing essentially a representation of the ciphertext. Uh, if Bob sends, uh, money to Alice, you are adding an encrypted amount to an encrypted balance. Uh, so effectively, you know, uh, what you're doing on Ethereum is, uh, kinda like a symbolic execution where you're at, not actually doing the FHE compute, uh, where you're computing essentially is, uh, a representation of it, right? So here we just hash the operation with handle one, handle two. You generate the handle three. And then Inco basically is abstracted away and we'll handle the rest. Uh, so now I guess onto the Eigenlayer part. Um, so, you know, we, we first, uh, started chatting with Eig-, Eigenlayer towards, uh, I believe it was October, November, uh, of 2023. And, uh, it was right after their blog post about, you know, um, how Eigenlayer can enable layer ones, specifically, Cosmos chains, uh, to be more secure using this idea of, you know, dual staking. Um, so, you know, I can dive a little bit deeper into, you know, the advantages that we see here. Uh, but we do, yeah, we do have a blog post here with Eigenlayer that's earlier, uh, this year that came out, we're talking about these concepts. And I, I do think, you know, it is sort of a interesting, uh, design space. Uh, so, you know, especially for layer ones to benefit from, you know, additional security, but also, um, yeah, I guess I can talk about it a bit more here. Um, so basically there, there are two essentially, there's, uh, when, when you launch a layer one, typically you have this cold start problem. And it's actually really a problem around two points. One is, typically as a layer one blockchain, uh, new layer one blockchain, your market cap is going to be smaller. Uh, so there are two consequences"
  }
]