[
  {
    "speaker": "Rob",
    "content": "Marketplace and they can also access this coordination to enable shared sequencing."
  },
  {
    "speaker": "Rob",
    "content": "Uh, alright. So, let's talk about how EigenLayer fits into all this though."
  },
  {
    "speaker": "Rob",
    "content": "EigenLayer is uh, has a a bigger part in the finality layer, which I'll get to, but the really neat thing about EigenLayer restaking is that it really simplifies base sequencing. So, Espresso uh, can absolutely enable base sequencing. And base sequencing is when you enable the Ethereum L1 proposer to also build blocks for rollups at the same time that it's proposing a block on Ethereum. And the way that EigenLayer helps this is that you know, every node that is staked in Espresso's protocol is actively participating in Ethereum's protocol. Um, they are actively staked in Ethereum's protocol. So, you can assume things um, you know, you can generally assume that they will be up to date on the latest state of Ethereum, etcetera. And then also because you, you know, that the Espresso uh, software can coordinate with the the L1, you know, Ethereum client, you can then actually sync up the two. So maybe an example would be um, okay, I'm the L1 proposer, and I want to build rollup blocks in Espresso. Well, that's only valuable if I'm building the blocks during my Ethereum proposal slot time. And the tricky part is you need to sync those up to make sure that that's what happens. Because otherwise it could be very common that the case is the L1 proposer gets sequencing rights on Espresso, but it's like after their proposal time, and then they can't do anything meaningful with that. Uh, so EigenLayer because you can work under these assumptions that you know that nodes are actively participating and proposing in the L1 protocol, this makes base sequencing a lot easier, which is really cool."
  },
  {
    "speaker": "Rob",
    "content": "Um, oh yeah, had a couple of images of base sequencing. Uh, yeah, Ethereum proposers. And I would argue that this kind of gives us composability plus plus. So, our initial definition of composability was that all of these different chains could interoperate together, and they could act as one chain. But we didn't really mention the L1. And so, this composability plus plus, means that we get composability between rollups, but also between the L1 and rollups, which is a very very powerful property to have."
  },
  {
    "speaker": "Rob",
    "content": "Alright, now I'm going to go onto the fast shared finality portion of Espresso."
  },
  {
    "speaker": "Rob",
    "content": "So, we have our same picture of the auction. The rollups sell their sequencing rights, and sequencers bid on them. But, we're gonna add a few more steps."
  },
  {
    "speaker": "Rob",
    "content": "So, this is the marketplace, and then to the right we're adding the finality layer. So, what happens with the finality layer is that the blocks that the sequencers produce get sent to the Espresso network, and the Espresso network finalizes them. And this finality, ultimately it's not Ethereum finality. The rollups do still have to settle for Ethereum. But, the idea is that the finality you get from the Espresso network is extremely strong, that you can have a very good guarantee that it will actually be final on Ethereum. Um, and the way that this finality works it's uh, you know, it's a consensus protocol that we've designed, it's called HotShot. It's um, in my opinion it's really interesting. It's based on HotStuff. It's a BFT protocol. So, it has the same um, it's very similar to how Ethereum use, uh, does finalization where you have, um, you know, one something, a block proposal, and then everybody has to vote on it, and then it gets like justified, and then everybody votes on it again, and then every, it gets committed. This is a very similar scheme. Uh, but the really important, important parts are that, uh, this scheme can go so much faster than Ethereum's finality. So, you can generally expect to get finality between, um, you know, hopefully with less than 4 s on average, which is really good. So, this is great. And this finality layer, uh, is really strong. But, let's see like why do we need this fin, finality layer anyway? It's fast which is great, but like, do you actually really need that? Um, so, this finality layer gives us a few good things. One thing is that it makes it easy to enforce composability properties among rollups. So, a user likely wants an atomic, um, cross-chain transaction. Atomic means that they want both sides of their transaction to succeed on each chain or they want them both to fail. They really don't want one to succeed and one to fail. So, we want to enforce this atomicity. And to do this, rollups need to be somewhat aware of other rollups. Um, generally, rollups are not aware of other rollups. They have no idea how another rollup might execute it's VM. They really don't know. And so, we can have uh, you know, other services that come in and can do this uh, can be knowledgeable of like, both rollups at once. And then, where Espresso comes in, is that you don't have to wait for the rollups to settle to Ethereum before you can figure out what the shared state is. Um, this is, this is important as well because rollups do not all settle to Ethereum at the same rate. Some rollups settle every few minutes which is great, but then you may have a ZK rollup that's only settling once every 30 min to reduce their gas costs. Uh, so, this is really not ideal if you're trying to figure out if your transactions executed or did not execute. So, since Espresso, or since both of the rollups that your transactions are on, are finalized through Espresso at the same time as each other, you can then immediately see, okay, my cross-chain message worked or it didn't work. And this is really good. Um, so, yeah, this reduces a lot of the latency in these cross chain, uh, this cross chain experience. And then, the other thing is you get faster composable finality than the L1. Uh, this is actually very similar to what I just said. Um, the, you know, normally you would have to wait on Ethereum to see if your transactions made it or not. And in the worst case, you know, the rollups might have to wait until they're settled on Ethereum to even check like, what the other rollup is even doing. And now maybe there's L1 function calls involved, and this gets really expensive. Maybe they need to verify a ZK proof of another rollup, and this gets like, expensive. So, the fact that you can do this before settling in on Ethereum is really advantageous."
  },
  {
    "speaker": "Rob",
    "content": "Um, alright, but then let's finally go to the EigenLayer part. So, how does EigenLayer help all of this? So, first, EigenLayer gives you very strong economic security. This is probably the reason most people are using EigenLayer for restaking. You know, if we want this finality layer that's really strong and that can give these really strong pre-confirmations to rollups, we need to have a lot of economic security behind that. The easiest way to do that is to use Ethereum's economic security. The really wonderful thing about Ethereum that makes it very unique compared to other change is that, chains is that it has so many nodes participating, the nodes are relatively decentralized and it has so much economic security behind it. So, we can, through restaking we can basically use that economic security, and we can have a very secure network. We've actually designed our network to be able to handle all of the Ethereum validators if at one point it needs that. Um, and so, this is really, really great. This gives users a very strong guarantee that a pre-confirmation from Espresso will be finalized on Ethereum. The other thing it gives us is transparency. So, when different projects use EigenLayer for restaking, it's very transparent, um, where stake is allocated and which nodes, like which operators are running nodes in multiple protocols. And in my opinion, this is very helpful for risk management. Um, in the case, for example say that you have Espresso is running and you have another project that's running, and a lot of the operators overlap and they're run by the same operators. This other project has this major slashing event, and a lot of money is lost. Well, that is going to affect Espresso. Like, even if it's not the exact same stake that is being used in Espresso, those operators probably now have to cover their clients losses. So, they're going to withdraw from Espresso, etcetera. And if you have transparency into this process and it's very public, the, the network can be sure to maintain accuracy of it's uh, economic security. So, the worst thing that would happen is that you say, oh, Espresso has $10 billion worth of economic security. But, then, some slashing event happens over here, and actually, Espresso doesn't have $10 billion, but it's operating as if it did. You really don't want that. So, with EigenLayer you can get transparency into what's happening with other protocols, and this reduces the risk, um, of Espresso. And then, the final thing is shared infrastructure. So, Espresso will have slashing for, um, attributable faults. Very similar to Ethereum. Um, you know, we will slash if someone tries to double sign or equivocate something, etcetera. And the good thing about EigenLayer is that a lot of projects can use the same slashing infrastructure. Each project might write their own specific slashing rules, but the shared infrastructure is very important because slashing is something that is very persnickety. You really need to make sure that you get it right. You really don't want to slash people due to a bug in the software or anything like that. So, having a shared infrastructure that everybody can use, can audit, etcetera, is, is really powerful and making sure that it works."
  }
]