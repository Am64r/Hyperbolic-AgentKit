[
  {
    "speaker": "Rob",
    "content": "All right guys, welcome back to The Rollup. Today we have a presentation around ZK coprocessors and the relationship of Brevis and EigenLayer. What I'm looking forward to today is to understand uh why a coprocessor needs to be in AVS, what advantages there are, as well as the security implications. So looking forward to kind of diving into the technicals of what a coprocessor is, and then why it makes sense to be in AVS. Welcome Mo, really excited to have you here, and let's jump in."
  },
  {
    "speaker": "Michael",
    "content": "Hey guys. Uh great to be here. Uh I'm Michael, co-founder of Brevis. And uh I'm here to talk about uh, you know, how do you use Brevis which is a smart ZK coprocessor to build data-driven dApps. And uh before we dive into what coprocessor does, uh let me kind of use analogy so that everyone can uh better understand what are the purposes of ZK coprocessor. So let's look at the history of Web2 evolution um in the last 20 years. So if we look at Web2 before 2000, it is really built on this asynchronous-based architecture, where you have a single web server that does everything. So every user's request will come into the web server in a sequential manner, and the request is handled one at a time. And this monolithic server really does uh all of these, you know, things in sequence in a sequential manner. So request handling, access control, computation, data access, then return to the user the result of the request. Uh it was very clear back then, you know, as the scale of internet uh explode. um This kind of architecture won't really scale because this is really built built based on this very synchronous and monolithic architecture. This is why in modern Web today, we are powering the entire modern Web2 world with this asynchronous-based architecture. Whereas the web server itself is just acting as a coordinator of a series of specialized bank-end services. Now, all these different users can essentially query this web server and the web server will just turn around and call these specialized banks back-end services with asynchronous function calls. And these specialized backend services will do its work, and then send result back to the web server with callback functions. And then the web server acting as again a coordinator, will assemble result from different specialized services, and return to the user a coherent um request result. So this is how, for example, Facebook, um Twitter, um in essentially every Web2 service work. And this is how it can scale, because now you're not limiting to uh the uh computation resources of a single server. Instead, uh you have the single server to coordinate multiple of the server resources to work for you in a concurrent manner, and in a scalable manner. So this is how we scale Web2. Now, if we look at Web3 today, the situation is actually worse than Web2 before 2000. Right now, the smart contract platform or the EVM mostly are acting as the synchronous web server, essentially. The smart contract has very, very simple computation capability. And it also has very limited data access capability. For example, you know, smart contract can only access the data in one point in time, which is the current point in time. There is no way for smart contract to access actually access historical on-chain data, such as events, transactions, and states. And because the smart contracts are running on blockchain, which are essentially replicated computer and replicated storage, um distributed system, you know, with extremely high communication overhead. So we are actually in a much worse comm situation than Web3 today. Because, you know, we're actually in a much worse situation than Web2 because the computation resources is even lower than a single server. So how can we break this? Right? So, you know, let's first understand the problem a bit deeper. For example, if you want to build something very simple, such as a trader loyalty program, which is available on every centralized exchanges. Someone traded a lot in the last months, you know, um and then uh the the the centralized exchange should be giving the user a trading fee discount in the next month. This is very simple and available in every centralized exchange. But if we look at all these smart contract powered dApps, none of them has that particular feature. The reason for that is because, as I mentioned, running this type of data-driven computation on blockchain directly, involving uh involve doing a lot of merkle proofs on chain directly. And this kind of extremely complicated and expensive computation makes it infeasible to run on smart contract platform. For example, if you want to generate a single proof of a single user on Uniswap uh for a month worth of trading volume. The time it will take is eight hours and the transaction fee uh is $40,000. So what this means is that only the smart contract platform then you or any smart contract or any dApps. There is no trust-free access and computation on historical on-chain data available. Now what Brevis does here is to introduce this asynchronous architecture to Web3. Where if you use Brevis, that you can treat the blockchain as this simple coordination layer for off-chain computation resources. Now instead of doing all the computation on blockchain directly, you can migrate very complex and data heavy computation of the blockchain into an off-chain environment. And in this off-chain environment, you can do the computation and not only the computation result is done, but also you can generate a zero-knowledge proof to attest to the fact that this computation is correctly done. And then you can take that computation result along with zero-knowledge proof back to the blockchain, so that blockchain can run a very simple verification process to verify the computation is correctly done, and use that computation result directly in smart contract. Using this architecture, you expand the capability of blockchain on-chain computation to tap into effectively unlimited computation resources off-chain. But at the same time, you're not introducing any additional trust, because every computation step is encapsulated in zero-knowledge proof. So that you know every single step of the computation is done correctly, as long as you can verify the computation result on-chain. So, there are multiple components uh in Brevis stack. Today I'm going to focus on just the ZK data coprocessor part. What ZK data coprocessor does is it, you know, allows you to do this type of very specialized computation on chain off chain, that therefore allows smart contract to have access to any historical on-chain data, and do computation on that. And you can use these computation result on chain in a trust-free way. Now, you know, using the Brevis ZK coprocessor is very simple uh from a developer point of view. Uh even though it is built on ZK, you don't actually have to uh understand anything about ZK circuit itself. Um the first step you need is to just specify what kind of historical data you want to read. Such as storage states, block information, received beacon chain state, which include what is the gas price for example, transaction data, accounts. So all of these data um, you know, are available for developers to choose and use. For example, this very simple code snippet here, uh demonstrate you how to uh access a user's historical trades on Uniswap um in the last 30 days. And then the second step is, you know, now you have the data available, what kind of computation you want to run on top of these data. So we provide a very easy-to-use data-stream based API, where you can manipulate the data you get in the first step, using very high-level and easy-to-use APIs such as map, reduce, filter, group by, sort and zip. And you can calculate things like sum, you can calculate things like average, you can do filtering based on certain criterias, you can merge different data together to construct into complex logics. And you know, of course, we support all the basic logics and arithmetic computation on top of these data. So for example, this three lines of code allows you to calculate a user's trading volume on Uniswap in the last three months. And then finally, um, you know, after uh you compute the result of the computation, and also generate zero-knowledge proof. So note that this generation of this zero-knowledge proof is transparently done by the Brevis prover network. And you can actually use the data and post the data back to the blockchain, um and you know, allow the smart contract to directly utilize that data in the business logic."
  }
]