[
  {
    "speaker": "Guest",
    "content": "Space or ZK auction computing space uh there are two models you can choose You can choose to use pure ZK which is like you whenever you know a computation request comes in you do the computation entirely in ZK This works fine um but also at the same time um you know um we need to know that this type of model also incurs high cost in certain cases Uh because zero knowledge proof um despite it's um you know uh amazing progress in the last several years still is quite a uh you know a costly kind of computation process to run Now what we introduced in uh Brevis which is a very unique thing is that we introduced this kind of optimistic co-processing with a ZK fraud proof So we can allow a proposer to essentially do the computation off-chain without generate ZK proof and submit the computation result on the blockchain as a proposal just like an optimist roll-up Right so and then you know if uh and then a challenge window will be opened and during that challenge window if uh any watchtower detects that this particular result is wrong then ZK fraud proof can be generated to challenge the result and correct the wrong result and slash the proposal No the question is like who um what is the proposer Right so uh you know we can use a centralized entity uh or like a centralized sequencer as a proposer But you know what we feel is actually more reasonable is to essentially provide some level of default security at the proposing stage This is the where EigenLayer comes into the picture uh where we use an EigenLayer AVS as the optimistic co-processors proposer So this particular EigenLayer AVS node operators will be able to compute the co-processing result and the off-chain computation result upfront without actually generating ZK proof and they can submit the result to the blockchain Now immediately that result is actually secured and guaranteed by a certain level of proof of stake security Right so like no matter how um you know you know it depends on how much like uh each res take is actually dedicated to the Brevis AVS That level of security is already there But the challenge window is still opened for applications uh you know application can choose their own challenge window Some application may uh be able to accept the result upfront directly but some application may actually want to have a challenge window And during that challenge window uh you can still generate a zero knowledge proof fraud proof to actually challenge uh the initial submitted result If the challenge is successful then the corresponding uh you know kind of validator or operators who submitted the wrong result will be slashed Right so of course you know um we believe that this particular model will actually be used by a very large amount of application uh because it offers the same level of trust assumptions as the pure ZK uh you know uh based solution but also has significant lower cost comparing to the ZK The only tradeoff here is latency But we do see there is a large category of use cases for ZK co-processors that are not latency sensitive For example if you want to compute a monthly trading volume for user then you probably don't you know uh don't don't need to kind of really chase for that particular seconds of latency or 10 hours of latency You know as long as the cost is like lower then you probably will actually use this kind of hybrid model So this is how we use um AVS as a way to lower the cost for ZK co-processing while maintain the full trust fairness of the entire architecture"
  },
  {
    "speaker": "Andy",
    "content": "Yeah I mean just briefly back on that slide uh um I I don't I I don't understand quite how the slashing part is going to actually make a difference for this model Right like like how cuz what theoretically slashing is going to involve slashing the Eigen token um which I I I'm just struggling to see how how slashing is going to be enforced or used at all in this model um and you there's going to be any sort of kind of crypto-economic security here"
  },
  {
    "speaker": "Guest",
    "content": "Yes So you know uh uh I guess like uh just to kind of quickly run through this entire flow here uh so instead of sending everything directly to a ZK proving service the smart contract now will send the computation result request directly first to an AVS Right so the AVS will now generate a crypto-economics economically validated result So this is like the proof of stake result The proof of stake result will be posted to the blockchain as in need"
  },
  {
    "speaker": "Andy",
    "content": "Just real quick That's like an optimistic uh result because it's crypto economically"
  },
  {
    "speaker": "Guest",
    "content": "That's correct That's essentially optimistic result Right so that's essentially optimist result but it's stronger than a centralized sequencer uh based optimistic result because it is guaranteed by a crypto economic security um you know uh off the res take the AVS And uh you know now we'll have a challenge window opened during the challenge the application will not directly use the result you know it will actually wait for a challenge This result will be essentially put into a quarantine zone And during the challenge window if some watch tower sees that okay wait that result is actually wrong So how do I challenge this Well you know the way to challenge that is pretty simple It will just generate a zero knowledge proof of the correct computation result So now the challenger can then submit a result to the blockchain saying okay look now I have a zero knowledge proof uh and also the correct result And the blockchain can verify the result because ZK proof uh can never be wrong you know barring the implementation bugs and the you know uh and and and like code issues But like in theory you know the zero knowledge proof can be can never be wrong And then you essentially have the uh challenge accepted by a blockchain and when the challenge is actually accepted by the blockchain the corresponding um you know uh it it basically means that whatever initially was what what what whatever was initially submitted was actually wrong and whoever signed on that initial proposal should be slashed So this is like the how the slashing works"
  },
  {
    "speaker": "Andy",
    "content": "So um I I I think that makes sense right Cuz uh there's like an there's a proposer that proposes a uh a verif uh solution um to the computation request optimistically Um and then there's a challenger that submits a ZK proof And if those contradict then uh the proposer who was proven wrong by the ZK proof is slashed because they proposed something incorrect Um That's correct and you know you mentioned that like a ZK proof can never be wrong I agree with you in principle but it could be malicious right And so I could maliciously submit something that is going to you know say that the ZK proof uh contradicts the original optimistic solution but maybe maybe I'm I'm not right right Maybe I'm submitting something that is malicious and I want to you know try to steal funds or whatever How you know how how if I can submit a ZK proof and it's just taken as truth then the optimistic proposer is slashed you know regardless and my my malicious ZK proof is taken as correct But how can we deal with a malicious ZK proof that may or may not be incorrect you know how how how can you verify the correctness of the ZK proof and make sure that in fact the optimistic proof was incorrect and my ZK proof or excuse me the optimistic proof was correct and the ZK proof was incorrect"
  },
  {
    "speaker": "Guest",
    "content": "Sure uh you know so the question is like how we can essentially verify whether a ZK proof is indeed correct or not So like I guess you know this is a great question that you know we we kind of need to expand a bit on how these computation gets bind together Right so whenever there's like a off-chain computation Let's say there is some function you need to compute off-chain and uh for any function there will be input Right so you know whenever we define a function Let's say you know let's take a very simple example This is to compute a user's trading volume on-chain And uh you know uh whenever that is like defined there will be two things generated like one is the ZK circuit corresponding to that computation So like basically you know if you feed all these users transaction this particular ZK circuit will uh understand and figure out whether these transactions are actually belonging to this particular user and if they're from Uniswap and they you know what is if so what is the actual kind of trading volume of this particular user Right so that's kind of the the off-chain circuit part Now uh for any ZK proof there will be a prover and there will also be a verifier So the verifier is actually uh you know concurrently generated based on the circuit that they want to verify So in this particular case this verifier will be only able to verify the computation result of the user trading volume And that verifier contract will be automatically generated and deployed to the blockchain So essentially blockchain itself is now becoming the verifier There is a smart contract that is running the actual verification uh algorithm and process So you know whenever actually compute something off-chain as long as the corresponding bind the V"
  }
]