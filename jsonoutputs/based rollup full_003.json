[
  {
    "speaker": "Guest",
    "content": "directly just call the the EMM smart contract on on the on the on the other L2, too. So for the user this kind of like very seamless there would be like only one transaction just to call the call into his own smart wallet. It would automatically check the data on L1. It would automatically call the other smart contract on the on the L2, too. And then these tokens transfers will just happen as they make sense, so uh this tokens smart contract would also be like deployed on the L1 which makes the tokens smart contract available on all the L2's. And then depending on where the balance is for the user it could be on the same chain as the the smart wallet. It could also be on another chain. It doesn't really matter. Uh, it just fetches the correct balance from like the the chain that that that that is storing the funds. Swaps them on this EMM smart contract. So at that point those two tokens do need to be on on this specific uh chain. Uh, but then afterwards again you can just transfer the tokens to whatever chain, the L2 that you want. Um, so that's kinda like very easy for the user. Simple transaction as they are used to, uh just like internally, it it does like multiple cross-chain things. Um, let let's keep going to the contracts, because there is some some code there. Uh, and then yeah, shortly like what uh what a what a Gwyneth block uh block looks like. So like, there would be like, each L2 would be its own thing, but there would be like a single like transaction list containing all the different uh transactions on all the different like L2s. So it's up to the builder to kind like decide which transactions make sense and also which transactions can actually build because if you want if a builder wants to create the the like execute the transaction that touches multiple chains, then the builder does need to have like all the state for these chains that are being touched. Um, so depending on kinda like which chains are like the most popular or have like the most value, builders want to be like, pick and match which one they actually want to sync that and so that they will be able to actually execute execute transactions that touch uh all of those chains. Um, so yeah, it's kind of like up to builders to kinda like make sure this single composability actually works in practice uh because they do have to sync the multiple chains. And then yeah, the builds the builds a block. This builds this kind of like super block is proven like in a single go, so only like one proof required to to be able to prove yeah, uh any kind of like all the all the different L2 transactions. And then uh yeah, it should should just work, except that there's kind of like a D-DOS risk uh as in like the build, like if you do like a transaction and this transaction can touch like lots of like different chains, uh so the build kind of like has to know for a transaction which chains will be touched, otherwise he might start executing a transaction and then see like, okay, I actually don't have like the the necessary state to to execute this transaction. So that's why the the transaction format will also have to include like a list of all the chains that will be touched, and if the user kind of like is wrong, then the gas will still be used and the the transaction will simply revert. "
  },
  {
    "speaker": "Rob",
    "content": "Alright, so, we're we're looking at some uh block building process more in depth, talking about some MEV here. Um "
  },
  {
    "speaker": "Guest",
    "content": "Right. Let's go. "
  },
  {
    "speaker": "Guest",
    "content": "Yeah. So like let's start from like how does the MEV and PBS paradigm work nowadays on L1? So, um obviously we have this builder, which has a lot of transaction in the mempool, and the builder will just pick whatever transactions that are profitable to form profitable to form a block and submit this entire block through the PBS pipeline, which you have a validator and all that stuff, blah, blah, blah. Um, and the builder gets revenue from MEV plus tip, right? But what about if we add the base stuff in the in the paradigm. So we'll have um L1 builder which is also a based L2 builder. Uh, because that's the def- definition of base roll-up, your L1, L2 sequencer is also L1 sequencer, right, L1 validator. So, in this case, then um the builders transaction pool, the mempool within the database will also have the access to L2 state. And and also the L2 mempool itself. You have a L2 RPC endpoint, right? Um, and in this case, the builder will just directly build the L2 blocks. You see this pink block over here, and this pink block is being built is i- in the exact same way as L1 blocks, because you you still receive MEV plus tip, or if you're if you're L2 works differently, you might have other L2 fee uh accounting mechanism, but um but the whole L2 block is being packed in a roll-up operation. Right? Like when you have like roll-up transaction proposal every every out of the the entire batch is being is being batched in like a blob and a transaction with uh uh 4, 4, 4, blob or something. So this is how you ro- wrote it up nowadays and it actually works very nicely in a base sequencing uh mechanism. Um, yeah. "
  },
  {
    "speaker": "Andy",
    "content": "Yeah. So just briefly here um s- so I understand how uh let's say you have multiple base roll-ups, app chains, or just an entire sort of, you know, base roll-up L2, they can settle atomically in the same L1 block, because of the way that the sequencing happens and that can allow them to have uh, you know, basically like they can they can read each other's state and have really well uh really fluid cross domain interactions for asset transfers and messaging and things. But like you're giving away all of the transaction ordering or at least from my understanding, you're giving away transaction ordering and sovereign sequencing as a form of revenue back to your sequencer and giving that to Ethereum L1 validators. And that doesn't seem like a great business model for app builders who want ac- accrue revenue for their block space demand that they have for their chain. How are you guys thinking about this? "
  },
  {
    "speaker": "Guest",
    "content": "Yeah. I totally see your argument, but actually it doesn't have to be that way, right? That's why I leave it open for the L2 sequencing protocol without specifying. Okay, this is like a absolute uh anarchy that you can do anything. It's actually not the case. Like we can literally sell execution ticket on L2. Right? If you're a sovereign app where you have blocks block space that are that are profitable, you as a protocol can sell execution ticket to random block builder that wants to build your block. And we can also uh receive revenue from 1, 5, 5, 9 base fee. Because as you know, like people modify the fee accounting on Ethereum all the time, and you can also do that on L2 in any sorts of manner that you want, such that you you you capture back some of the base fee that are about to burn, right? And in fact, that is how Tycho work currently um, that we literally out of the base fee generate from Tycho uh congestion is being transferred to our to our treasury. Um, so, yeah. So, and you don't have to give up all of the revenue. "
  },
  {
    "speaker": "Andy",
    "content": "Yeah. Cool. Understood. That's a good, that's that's good to know. It's like as far as like the spectrum goes, I think a lot of people see things binary sometimes in technical designs but it's often not. Um, the other thing with specifically with uh Gwyneth and Tycho's kind of booster designs with regards to the horizontal scalability, um, it seems like the design works better as more booster roll-ups come onto the system because then you get this kind of expansion of composability across different chains with the same sequencing happening. And like you can get a lot more scale. Like all I'm saying is like if there's three booster roll-ups, it's like, okay, great, we can atomically compose amongst three different applications or ecosystems. But if there's like three thousand, then it's like, oh, like this is a big problem right now in any sort of EVM uh centralized sequencer or even like in uh proposed decentralized sequencer manner. Um, there's incentive issues and all these things. So like it really does seem like this design scales the value in people's eyes I think will scale exponentially as the chains adopting the sequencing method uh grows. So I just wanted to also make that point and see kind of if you guys agree. It seems that you do. "
  },
  {
    "speaker": "Guest",
    "content": "Yeah. "
  }
]