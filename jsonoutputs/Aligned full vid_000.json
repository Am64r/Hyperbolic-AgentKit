[
  {
    "speaker": "Rob",
    "content": "Welcome to another episode of the Rollup's Eigen Layer Series. Today we are here with Diego Kingston from Aligned Layer."
  },
  {
    "speaker": "Diego Kingston",
    "content": "Thanks a lot, uh, Robbie. I am as you said, co-founder and head of research at Aligned, and we are dedicated to verifying zero-knowledge proofs. And so, I am going to make a brief presentation on, on the topic. Please feel free to interrupt me if you have any questions. So, let's start with the problem we are trying to solve. This is the problem of building decentralized applications. And it will be clear why we need this technology in order to help, for example, blockchain scale, or solve some of the problems we encounter when building this type of applications. So, let's start with the beginning. Blockchains remember are verifiable computers, okay? They coordinate among different parties, and the way we, uh, ensure that things are done properly is via re-execution. So everybody has to redo the same work, and then reach consensus. Okay? The problem we have with this is that, uh, all the parties have to, have to do exactly the same amount of work. And the problem is that then the weakest devices in the network, uh, become a bottleneck. So if you take a look, for example, at, uh, Ethereum currently, it can process around, uh, 10 to 15 transactions per second. And if you want these to, um, to scale to bring like millions, and even billions of users, we have to make the amount of transactions go up. So, how can we solve this? Uh, luckily, we have succinct integrity proofs, or sometimes we will call this like, CK, for, um, its acronyming, uh, zero-knowledge proofs. But we care about this property of succinctness, which means that the proof is short, and with them, what we can do is show that we did a computation right, um, in a, in a manner that is both time and communication efficient. Okay? So, the idea is that I, as a party, can generate this proof, and all the other nodes in the network just verify this, and they spend, uh, less work than I had to do to run the computation. So, this helps, uh, a lot scale. And, um, the good thing is that we can create, uh, proofs of very complicated, uh, computations. For example, we can prove an entire block of transactions, and then the parties just have to verify this very short proof that they can do it in maybe a few milliseconds, even on, for example, cell phones. And we don't need to give them all the information of all the transactions, and everything that has happened. We just need to give them some information, maybe on some public inputs, and, for example, the output of the program, and then they can just verify everything. Okay? So, this, uh, solves the problem in the sense that, what we can do is then delegate this computation to another machine, and then it can submit to the network the proof, and the rest has to do work. In that sense, um, we can then make blockchains more powerful by adding other computers doing computations off-chain, and submitting them on-chain for verification. Um, so we are solving the big problem that you had in blockchains, that if you add more computers, the blockchain isn't faster because every, uh, node has to re-execute. But with this, you get to scale up, uh, without losing any of the guarantees that you want, okay? So if you want to build the apps, CK, or this integrity proofs, are a core primitive. So, how do these, uh, proofs work? The idea is that, um, if we have a way of proving what we call an, NP-complete problem. That is to say, a problem which we can verify its solution in polynomial time, for example, that can be proving that we have a valid assignation, for example, of a Boolean circuit, or, um, for example, knowing that, we, we have the solution, for example, for a Sudoku. Okay? Solving a Sudoku may take you a lot of time, but if I give you the solution to the Sudoku, you can do it with just a few checks, and, and you're sure that, that you did it properly. And the idea is that, if we have one of these NP-complete problems, then any other problem in the class NP can be, uh, reduced to this, um, NP, and if we have this, this, the proof, then we can generate the proof for this, um, reduction. Okay? So, we have to choose which, um, proof technology is the best one for what we are trying to do. And the problem is that, um, or the good thing is that you have like different trade-offs. So, for example, you can have proofs that have larger proof sizes, and so, that may have an impact when you want to, uh, check them in the blockchain because then you have to pay for a lot of space. Then some have like, higher verification times. Others like, have, uh, higher proving times. Some can be, for example, post-quantum secure. And others are good, for example, have like, easier properties of, for example, what we are going to talk later, which is proof recursion. Okay? So, we, we have like a set of technologies, and we have to choose which one is best for, um, our purposes, and it may be that for our application, there is one that is like, uh, a lot better than the others, and we would like to use it. So, here there are like some popular, uh, design choices, uh, that you have. For example, you can build, um, your proof system using hash-based, uh, primitives, or maybe you can use elliptic curves. Then you have different choices regarding, for example, the finite field you are going to use, if you are going to use, for example, binary fields as in Venus, small fields as in Stark's, or even, uh, bigger fields because you are going to work with elliptic curves. Then you have different ways of representing your computation. So, this is more or less what happens when you write a computer program. Okay? When you write a computer program in general, you write it in a higher-level language, then it gets compiled into assembly, and then it gets compiled to byte code, and that is what the computer runs. So, in this case, to be able to generate these proofs, what we have is, in general, we have a program that we want to prove, but the problem is, that is not the language our provers understand. So what we have to do is that some kind of compilation, which, we generally call like, uh, building, um, arithmetic circuits, or arithmetizing, okay, expressing our program as a set of algebraic constraints. And, depending on the choice, it may be easier to do some things, it may be more efficient, less efficient, and so we have to think a little bit what we want to do. Then of course, there are like, some choices, for example, you want to use univariate polynomials, multivariate polynomials. You want to leverage something called the subject protocol. You have like plenty of options. Then you have some, um, proof systems that need a trusted setup, okay? In general, they offer shorter proofs, but at the expense of adding these extra security assumption. Uh, then of course, depending on the curve, or the hash you use, uh, it also affects, uh, the performance. And then you can, for example, use different look-up arguments, which are just specialized operations where you can go to a pre-computed table of valid input, and output pairs, and then show, for example, that your result is contained in, in that table. And you have also different types of, uh, look-up arguments. And so, what you see is that you get like, uh, um, large variety of proof systems. And you have to choose which one suits you best. So, here is an example of what, um, proving looks like, okay? This is just for what we call Starks, using, uh, CK virtual machine. The idea of these primitives is basically you write your code in..."
  }
]