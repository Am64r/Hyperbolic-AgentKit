[
  {
    "speaker": "Andy",
    "content": "Yep. It's starting like the three pillars that you described and the way that you kind of outline how this works from like a state perspective, it really it really sounds to me like a like almost like uh what Solana's calling network extensions, what Ethereum's calling roll ups. It's almost like this intent machine. You you guys are like building these programmable extensions for people to use within different ecosystems. And then simultaneously, you've been kind of taking the taking the uh the torch to copy and paste EVML too saying they kind of like there's not a lot there's not a lot of programmability upgrades here. There's not a lot of things going on that are really changing they're kind of pushing the the the needle. How are you seeing this intent machine and this way they are describing in intense in relation to kind of other scaling solutions that you're seeing out there and kind of like the tradeoffs between L2's and Anoma's design."
  },
  {
    "speaker": "Guest",
    "content": "Yeah, so they are just different things, really. Uh Anoma it's a distributed operating system um that is distributed incentive compatible operating system, it's an intent machine. Um it's you can really think of this as it's kind of like Windows. Currently we live in this world where everyone is running like these barebones CPUs like everyone has a very specific execution environment. And as a developer, I got I well I either stick to the same CPU or I now like rewrite my entire application for this other CPU, like if I go to the SVM, I now rewrite my entire application. And with Anoma just it doesn't matter which CPUs are running under the hood. If you can implement the operating system on top of the CPU, it just works. And so like your applications just become portable this way. Um plus, it networks all these different CPUs together. Um I think the reason why people get a little bit confused not confused, but like why they think like roll ups and network extensions are kind of similar to like require intents because well intents are like when you think about intents right like I have A to B, someone else has B to C, I do this 100 times, and then sort of the loop closing like closing the loop is then a sequence of signatures that makes this entire thing settleable on an L1. Um and so really like intense are just roll ups on demand. Like this is what you can build with intents. It's just on demand roll ups. Uh they just like come for free because like the architecture allows for this. That you can say, well I if you have a 100 people that all like wanna have some sort of sequential state transition, we can collapse this all into one bit of compute. And this is the nice thing. Like Anoma is incredibly flexible. It it Anoma does the thing that is really hard and that no one else wants to tackle. I'm like how do you give stable developer APIs to people? How do you network all these many different things together? Um like to me it's really a user trust like where does a user want to keep their valuable state? Do they wanna keep it on L1, do they wanna keep it on L2? That's the hard question. Like who secures your state? Who like provides like long-term data retrieval guarantees for your state? And this is really like the battle on the L2 side, I think, that I have like no stake in which is it seems that like there are many places where nowadays I can like offload my data too um and Anoma doesn't try to compete with this like it I I think this is like whether it's useful to have you get a the same VM in a slightly different color, a slightly different speed on a centralized server, like that's very questionable to me. I don't know. Like to me, as a developer, I can do exactly the same thing. Uh I want to be able to do new things. I wanna be able to do new things also as a user where I can say, well, honestly, here's my program. Here's my intent. I would like to trade some ETH for DAI. I don't actually care whether it gets settled on if you if you're if your Mania, on optimism arbitrum. Just give me whatever is quickest or cheapest, right like? And this is the kind of level of abstraction that I'd like to be able to use and I think that's going to unlock the next 10X um because it like it gives you something new where like you all of a sudden you start writing against the operating system and you go like well users pick the security preference execution preferences. Um and then the system figures out how to get them this. Right? Um I I think this is sort of the position we are coming from. The other thing is it's all about the state. It's all about the data. Um like roll ups on scaling solutions, if you define scaling solutions very strictly, um because like in the past, like we always defined scaling solutions as like we want to have some minimal that we wanted to have a constant uh cost on the L1 and uh for infinite user interaction on sorta like in a scaling solution. This is not currently true. Like like you're still bounded by how much data you can push onto the L1. Um and this is really like or onto some other DA, but like it's fundamentally bounded, right? And so I gave this great talk at least I liked it. I think uh it was a fun talk um at um Cosmocon in Tokyo um like three weeks ago or so um where I talked about resource plasma which is just this idea that like the plasma constructions are correct um and that you want to enable everyone individually to hold their state. And this like starts looking a lot like intents again where it's like, well, if everyone individually keeps their state, these systems become incredibly scalable because we actually only need to verify the compute on these systems. They like there's no particular reason why the fact that my e like that I have x amount of ETH needs to be tracked in some database on ethereum that that there's no reason for this. Like we should have a single merkle root to which I can prove. I own some key in the system um that like represents x amount of ETH and I can like modify this key under the under some conditions. Um and then like we actually get to this constant scaling factor of like there's just a couple of merkle roots that we track um on whatever security system we want um but like scaling is completely unbounded from this and like from time to time we just need to update the roots."
  },
  {
    "speaker": "Rob",
    "content": "I think we've heard people sort of allude to this idea where state is is uh localized to the user and not stored on some database somewhere, and people have had kind of fuzzy names for this, which is like user uh centric roll ups or a user centric view of the chain. And so you know where the name of this podcast is The Rollup. We we tend to believe that there's no central chain that is going to be like the the the one chain to rule them all. There's gonna be a million chains. People kind of extend that you know to to different orders of magnitude, but the the kinda extreme example is that every user is its own rollup. And and from from what I'm hearing."
  },
  {
    "speaker": "Guest",
    "content": "Everyone is their own chain."
  },
  {
    "speaker": "Rob",
    "content": "So yeah, could you kinda just expand on that a bit? Like what does that mean in practice?"
  },
  {
    "speaker": "Guest",
    "content": "Yeah. So currently, we live in this really weird weird abstraction world, right? Like where there are chains, and then they have some RPC nodes, and like there are some full nodes that like serve RPCs, and then as a user, I have like my RPC client, and I talk to this chain via some process via some like RPC calls, and in an ideal case, I get light client proofs, and so on and I have some like some security considerations. Um but the first thing to realize is state should only be co-located if it's valuable together. Like my personal data is not valuable if it's next co-located with Andy's data. That's no point. Like so state only needs to be co-located if it's valuable together. As in, for example if the three of us do regular trading, we should probably co-locate our state. Um but most people don't really do regular trading with a billion other people. Most users like most people like need co-located state for their local community like when I think about my parents, they need like co-located state for their like with the people in their village. That's like 2000 people kind of thing. They don't like it doesn't every month they leave, maybe and then they like need to take some part of their state to some other system where then co-locations like have performance benefits, but generally speaking, like they need fairly local state. Um and the other really important component here is um we will not be like you will not beat localized state or localized settlement unless you can violate the laws of physics and speed of light constraints, right? Like it is and this is like I'm gonna shit a little bit on the Solana and like speed of light thing here, but like you can never build a faster Solana than we can do local settlement uh unless Vitalik figures out how to violate the uh law of physics around speed of light, right? Because we always have to like uh like around the globe consensus around the globe network hops. If the three of us are in a room, we should just do local area networking um and then sort of like figure out what we wanna do and then settle this wherever we wanna take the state. Um and so my view of the entire system is that it is much cleaner as an abstraction when you start thinking of users just as one on one chains yeah um that just have some data themselves, and maybe they sometimes wanna move this data to ethereum. And maybe then sometimes they wanna move this data off ethereum, and like for example if like we want to trade a bunch of assets, maybe we have to move a bunch of the data to ethereum to be able to enable this kind of like like synchronous trading, right? Uh but most of the time, I'm very happy to secure my data locally. Um this also comes down to like my parents will never trust global Bitcoin or global Ethereum, no matter how decentralized. They will always trust the local community more so they should keep their local their data with their local community. Um so I think this is the entire idea like once you start thinking of users as one on one chains, you break this weird distinction between this is user, this is a chain, and you start arriving well all of these things are just controllers. We call them controllers which is really like consensus providers. They're controllers. They control some amount of state. It just controllers interacting with each other and then how do we enable a number of controllers to be able to connect to each other to like gossip data between them so that for example, if two users come together and just want to do like uh pairwise trading, they can just form an on-demand chain in the middle that they both move their data into, do the synchronous trading on that system, and then move it back out. Uh because global consensus is really expensive, right? Um and so yeah. I I think it's a much better abstraction to think of users as one on one chains and they're just like chains talking to each other. Um"
  },
  {
    "speaker": "Rob",
    "content": "Yeah."
  },
  {
    "speaker": "Andy",
    "content": "Yeah. A couple things there. We had a podcast with uh Stefan from One Balance, and he was pretty adamant on global consensus being silly from the lens of like, listen like if if I'm gonna go to Starbucks and buy a coffee, why does the whole world need to verify that this transaction was like accurate, done, and and settled by a global distributed set of validators when it's a transaction that is so minuscule in the grand scheme of the broader transactions. I think that thesis with regards to local consensus being more impactful paired up with also another recent pod that we had with Illia from Near, which was with regards to user-owned accounts and and kinda we were going back and forth on like this app chain thesis, and he's kind of like, no, you don't need app chains because you know Ethereum built it wrong where they they they built it without interoperability first, whereas Cosmos kind of built it with interoperability uh kind of baked in from from the beginning. Instead of doing this this way, you should just do kind of sharding and have every user account be its own kind of chain, its own kind of uh contract, and then have the applications and other users interact directly with that user's kind of contractor that that user's chain. And so this trend I see happening, and I think that like some of the leaders in in the space are pushing this idea forward. So for a more practical lens, how does Anoma push this forward from your perspective and kind of bring this together? Where does Anoma fit in this puzzle, or even more broadly like where does the concept of generalized intents uh fit into this to make this a reality, or how does that kind of play in?"
  },
  {
    "speaker": "Guest",
    "content": "Yeah, I agree with this. Everyone is their own chain. So like"
  }
]