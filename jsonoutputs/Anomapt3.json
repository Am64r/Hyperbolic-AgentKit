[
  {
    "speaker": "Guest",
    "content": "Yeah. So We'll just stop there. Um I think yeah, I agree with Stefan here. It's like silly to say, and like close, like physically close doesn't really... That's not a hard requirement, but more like culturally close. This is also the way I think about it, like uh you could... Because you can cut these examples a number of ways. You could say, well, there should be like a Starbucks specific settlement system that handles all global Starbucks traffic, or you, like, do a local economy specific cut where you go, like, well, the economy in Zurich gets its own settlement system. And, like, actually both are valid. This is kind of the point which is, like, the people in World of Warcraft will do lots of activity between themselves so they should have, even though they're geographically distributed, they should have, like, a like logically co-located state effectively that represents all of World of Warcraft. Uh, because that's the state they do lots of tight interactions with, right? Um, I think a little bit on the example with Ilya it's like where like sharding does this to some extent, but, like, the thing is it's still, like, a single global security model, and, like, I'm still not convinced that this is the right call. Um, also if it's near, like, it doesn't really change their idea. They still don't want, want a one world government and, great. Um..."
  },
  {
    "speaker": "Andy",
    "content": "Yeah, that was my pushback as well. It's still like scaling a single state machine. It's just a different flavor. Like I understand the core design principle but like it doesn't, it, yeah. It's not, it's not as appealing to me in theory as more kind of distributed networks, and, and having, you know, Ethereum as a settlement layer and scaling kind of horizontally, or even like, the way, like, like the way that Cosmos SDK and Tendermint have built their models."
  },
  {
    "speaker": "Guest",
    "content": "Yeah. Um, and like so how does this work specifically with Anoma? So Anoma is very agnostic to the specific security models that users care about. If all users want global Ethereum security, this is totally fine. Uh, this is fine. Like I mean, I don't personally agree with that, like some of these choices, right? Like, on the individual users, but if, let's assume we live in a hypothetical world of, like, everyone wants global Ethereum, that's great. This, like, works super well with Anoma as well. Uh, it's just about having this ability to have heterogeneous trust zones that connect with each other. Um, and so really, like, what this offers to users and developers is that it gives you this generalized intent where you can say, well, I'd like to do A for B, um, and I'd like to send to, like, my local trusted solvers first. Like, and if they can't solve this within the first, I don't know, ten minutes, then this gets, like, free for all, um, and then anyone can start solving this, right? It's like, or I only want, like, talk to my two trusted friends so I see if they can trade me this NFT. Um, and it's, like, it's a lot about this flexibility and building networking stacks, and, like, distributed system stacks that can, like, that aren't... Because currently all these systems are designed as, like, single global consensus systems, because they all started with this, and it's, like, fine, but it's very hard to pivot a single global consensus system into, like, no, this is a very loosely connected heterogeneous trust model with a very uh, with a completely novel, like, intent-centric execution environment, with the intent machine, right? And so our approach has always been, you know, if users want to use Ethereum, that's amazing, we're, like, I, I use Ethereum for, like, probably like 85% to 90% of the things I do. Um, because, like, this is my preferred community and all of them have my assets secured by it. Uh, but I just want, like, Anoma on Ethereum, um, and then I can put Anoma also, like, on an L2, just the intent machine. And now, like, on, like, Optimism and, um, Ethereum, the validators, or the full nodes, can decide to run small sidecars effectively, which are just processes, and, like, here you have all the flexibility on, like, you can connect to the same p2p stack so that I can gossip transa... Just raw transactions, um, to one p2p stack, and then the p2p stack figures out, well, this is designed for Optimism, this was destined for Ethereum, or you can have a, so, high-level integration where you start having Ano-, the intent machine, on Ethereum as well as on Optimism, and then you go, well, uh, now I have this, like, expressive generalized intent and maybe, so, the most tight integration is that you get some amount of chat sequencing between, uh, these different security, these different trust zones. And so Anoma is really just designed, like, it plugs in, also with, like, Near for example, or, like, one balance. It's, like Anoma really is not competitive, because it's, like, it's doing something that is very difficult, but I think it's going to be fundamentally the, like, fundamentally unlocked to connect a lot of these currently separate systems together into a coherent execution environment as well as a coherent, uh, not execution environment, like, a coherent operating system. That, like, as a developer I just built applications and when a user wants to move to a new system, I just have to build the operating system once for this new system, and then all applications just work. And as a user I don't have to pick whether I always want to be that, like, I have to don't make a fundamental choice, like, I can only be on Ethereum. I, like, I can never be on a roll-up. Um, but as a user I can just say, well, I currently have some state on Ethereum and I currently, I'd like to have some state on, um, L2. I described this as an intent. I send this to the same common p2p stack, and then solvers can just figure this out, right? Um, and this is really the way I think about this for, like, how Anoma, um, interfaces with, sort of, a, a lot of the existing infrastructure, and I think this is sort of the hardest thing, because everyone asks me, like, well, isn't it competitive to X or Y? I'm, like, no. Like, Anoma actually just tries to do something that's very needed, because, like, this is a fundamental need of, like, how do we defragment a lot of the state that's on all these random things. Um, and everyone else is just currently building, like, another execution environment. It's, like, I have no interest in this. We have, like, 500 of them, and it's very unclear that we need 500 of them, um, because I mostly care about local things. So yeah."
  },
  {
    "speaker": "Rob",
    "content": "Yeah. And the way to fix the state fragmentation issue is actually like fragment it way, way more, and then tie all the pieces together. Uh, and, and so Vitalik put out an article the other day, uh, glue and co-processors, and that's sort of the way that I'm thinking about this, because Anoma provides that generalizable intent framework for these different applications, co-processors, data, hubs, in order for them to communicate with one another. And so, uh, y-, you started to, to get into how Anoma communicates with some of the existing architecture. Are, are there any infrastructure changes that are required? Like, do we need all users to have their own account in order for Anoma to, sort of, mesh and merge that data together? Or can we start by Anoma as the glue between roll-ups, and then we can start to, m-, use Anoma as data starts to go more into these user-owned accounts, then we can use Anoma to tie those together."
  },
  {
    "speaker": "Guest",
    "content": "Uh, uh, yeah. I sh-, I sh-, I should have explained this a little better I think. Um, there's no central Anoma user account. There's no, like, central Anoma chain that you must interact with. I, I think these are, like, kind of, like, my, I have some amount of problems with the chain abstraction thesis and movement here, because I think it's always like, let's just, like, build it yet another layer of abstraction that everyone must sit at in terms of data and state. Um, there's no Anoma chain you need to interact with. Like, if you just want to use Anoma as a, as an environment on Ethereum, great. No Anoma chain ever required, just, like, directly use this on Ethereum. If you just want to be two roll-ups that connect, uh, Anoma's just sort of, like, this p2p substraight, this execution, this operating system that you can leverage to do this. Um, so there is no really, like, we don't have to m- I, I also think this is, like, a terrible deployment strategy when you actually think about it, because this is kind of like what we had with the L1 wars, where everyone went, like, or even the L2 wars right now, where everyone goes, well, move your valuable piece of state to new, my new shiny thing and it will fix all your problems. Yeah. Like, that's not going to happen. Like, so, and with Anoma it's much more, well, the infrastructure comes to you where you already have valuable state. Um, if over time there's maybe a local Anoma chain because you do lots of things in World of Warcraft and you want to have this, like, unified, um, like, optim-, optimized CPU for your World of Warcraft consensus instance. Yeah, maybe you decide to, like, move some state into sort of an Anoma native CPU run by the World of Warcraft community, but this is very much, like, an optional eventual thing. It's not, everyone, like, just generate your new account over here, and we will, like, direct everything from your new account. Um, so the onboarding path just looks much, like, much easier in my opinion. Where it's, like, the state can remain where it is, because, and, like, moving the state is actually the hard part. So, like, it's much easier to bring infrastructure to state than to bring state to infrastructure."
  },
  {
    "speaker": "Andy",
    "content": "Yep. That, i-, it reminds me of some of these different players of the chain abstraction landscape that are doing, um, you could say like permissions or orchestrations where, it's kind of like this idea of facilitating different cross-chain and multi-chain transactions, different types of interactions across, a variety of execution environments, um, where, where you guys, Fidenza appears to be more at the application kind of layer if you will where..."
  },
  {
    "speaker": "Rob",
    "content": "Actually we got in trouble for asking, w-, we were trying to figure out where to put Anoma on this map that we did. And like there was no category for it."
  },
  {
    "speaker": "Guest",
    "content": "Yeah. No. I saw, I saw that map, and I was, like, what the fuck am I supposed to do with this map?"
  },
  {
    "speaker": "Andy",
    "content": "Yeah, so what, so wh-, what was wrong with the uh, with the map? Or, better yet, what was, where does, okay so, let's just start with your view of chain abstraction. Like, what does the chain abstraction stack to you? How does this, how is this going to work? What is your vision for the chain abstraction? Let's start w-, with the bare bones, then you can roast us for the map, and then we can, we can kind of discuss how this is going to kind of play out."
  },
  {
    "speaker": "Guest",
    "content": "Yeah. So, I think, I don't think, like, users should still know which chains they're on. This is never going to go away, because this chains, are what the things that secure their state. Like, it's very important that you understand where your state is, because that's your fundamental security model, right? Like, you can never live in a world, we go like, well, my state lives somewhere but I'm fully abstracted on this, like, super abstracted chain, and, like, my state now lives on, like, two data cent-, like, two servers, somewhere centrally, right? Uh, like users need to fundamentally care about this. Otherwise, this is going to be horrendously insecure and people lose tons of money, right? Um, so the way I think about this is more, we want to give users the ability to, it's, it's not chain abstraction in that sense. It's more like, we want to build, like, there's an operating system abstraction so that users can go, that, like, applications can roam. I always, like, to use the example of mobile phones. Like, my phone that I bought, actually I think I bought this in the States, in New York. Um, like, I can use this in Switzerland. This is amazing! Uh, I can use this in China, I can use this in Australia, I can use this wherever I go. It's actually quite nice. Um, but this only works because we have a, um, like, we agreed on the base layer protocols for how phones interact with the network. And so I think of this much more, like, this is the kind of operating system, like, I can take my Word program, and decide that I want to run this on a Mac, or on a Power PC, um, or on some, like, esoteric, uh, CPU, uh, wherever, like, for example Windows just runs, my application runs. And this is what I want for users. That users go, like, well, I want, like, to do some trading. Um, and I can take this, like, trading capability to a number of different chains and I don't have to worry about, like, re-programming my, like, device, or my application on my phone, to work against this new chain. I just get a common abstraction but users still know about which chains they're on, because this is, like, this is the value these systems provide. Like, if users don't know that they're on a chain, or which chain they're on, this just seems like the easiest way for people to lose tons of money, because they start moving to insecure systems."
  },
  {
    "speaker": "Andy",
    "content": "And, and this is very different than, like, I think people think about this kind of abstractions like, well, we want to hide this complexity from users. Um, and like, no, this is, like, the fundamental thing. You can do this for servers maybe, because you can go, like, well, whether this is on in this AWS data center or that AWS data center probably makes very little difference, but whether you're on Terra or whether you're on Ethereum, makes a ton of difference. Um, and you should better know this. There's a difference. Like, this going to be problematic if users do not know this difference anymore. Um... Okay, so that's kind of your general worldview of chain abstraction, which I think there's a lot of points that we've heard, heard and a-, agree with and I think some with regards to users caring, I think there's room to disagree, with regards to like some users just, some users just may want to have security but may not care if it's base Optimism or Arbitrum, or if it's you know, X, Y and Z. If the chains themselves have very similar s-, security models, they might not care exactly about the name or the dynamic of the community."
  },
  {
    "speaker": "Guest",
    "content": "Oh, I fully agree with that, by the way. Like, um, to some extent it's, if you can, like, abstract security away, and go, like, well, these four systems have roughly the same security then users can just pick. Like, this is kind of why intents are nice because you can just pick. Yeah."
  }
]