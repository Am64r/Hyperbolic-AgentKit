[
  {
    "speaker": "Rob",
    "content": "So we have applications. You know, this can be managed by an individual developer, it could be managed by a team. Of course, when it becomes decentralized, it's managed by a DAO or an ecosystem. So for them, they have specific requirements that they might have for who can participate, how transactions are executed, what are the requirements there. This, of course, would require some type of information. The great thing about a blockchain is you have access to historical on-chain information. So this could be any type of historical information. But it might be off-chain information as well. So, you know, this could be, we've talked about a blacklist or a risk score or it could be, you know, someone who was involved in an exploit. You would need to build and identify that. But it could be even something not as controversial as that. It could be, hey, you want to interact with our system because you want to mint a stablecoin. Do you have sufficient collateral to be able to mint it? That's a, that's a rule, right? You're checking if there's sufficient collateral to be able to mint. And that might be something you're saying that there's off-chain data. So here you have, you have a need for information. Information that is on-chain or off-chain to determine whether a specific rule is met or not. To start with those two pieces. The last question is how do you actually enforce that those rules are met for every transaction? It's a little difficult for an application to do that inherently in their system because you're involving some type of compute, just not possible from a smart contract standpoint at a technical level. So now you need some way of issuing signatures. The way that makes the most sense is, is in a network of operators. You could have an individual operator that's basically think of them as almost like a notary. So they're checking everything and saying, hey, this transaction's coming in, does it look good as per the information that's been provided as well as the requirement? If so, yes, great. You can have an individual do that. Of course, if you have an individual, you're reliant on that one individual. And you're saying that I trust that individual to always do this and you know, stay awake at all times, maintain uptime. If anything goes wrong, they're going to make sure it's back up. That's a lot of trust because if they go down, suddenly now, that application is not able to receive any transactions. So here, you actually need a network of operators. So the easiest way to build this and, and they're designed to really issue signatures. So overall you're now envisioning a three-sided network to build and enforce pre-transaction requirements."
  },
  {
    "speaker": "Rob",
    "content": "And then these operators, what they need to do is they have to do really two things. One is compute. They have to do compute. As I mentioned, accessing any external APIs. And this can be used for a number of different use cases as well as they have to be able to function as archive nodes because they're looking for historical state. They should be able to reference any type of historical information on a blockchain."
  },
  {
    "speaker": "Rob",
    "content": "But this is a real problem, right? Because you know, building a two-sided network is, is difficult. Building a three-sided network is substantially more difficult. So now you're trying to say, wait, we have to build a three-sided network. Which part do we bootstrap first? How do we actually get this thing to even work? And it's always been a problem of building networks of which is your toughest side and how can you quickly solve for that? You always want to solve for the toughest side of your network to make sure everything else works. I think if it is almost like you're a plumber and you're trying to make sure that all the different pieces are unlocked because the moment that one gets blocked, the whole thing collapses and it doesn't operate."
  },
  {
    "speaker": "Rob",
    "content": "And this is where EigenLayer becomes really important. EigenLayer enables you to bootstrap the toughest part of the network and create a trust-minimized set of operators. In this way, you have an immediate way to launch a network of operators and say, hey wait, we already have this. In any other instance if you want to do this, you either start with a centralized system or you know, you might be a project and you're like, hey, I want to use crypto economic security. I need to go and launch a token to be able to create an economic, a crypto economically secure mechanism. That, like EigenLayer basically, allows you to go ahead and launch a decentralized network without having to go and do all that work. And then of course, the other solution here would have been to use something with a ZK type of style. The challenge, of course, with zero-knowledge is that it's slower and much more expensive. And for something like this, in which you're issuing signatures, you need it to be as light as possible. If it's anything that's not light, it changes the user experience fundamentally. It changes the way, it actually breaks the application experience. It becomes expensive, it becomes slow, it's something you don't want. So this is where EigenLayer becomes really important. You are able to bootstrap your operator network to be able to issue signatures and really solve the toughest problem."
  },
  {
    "speaker": "Rob",
    "content": "So now let's go in a little bit on like how we've thought about that design and really that architecture when we think about this mechanism of issuing signatures to enforce transaction prerequisites. So what we do here is a user interacts with an application interface. Let's take a bridge contract, for example, and we can use, we can use the Alio example actually. Maybe that's the simplest one because we've already kind of talked about it. So a user goes and interacts with the Alio, uh, bridge, um, interface. The user shouldn't have to do anything different. The problem is historically, I think in crypto, we've always thought about, oh, like, if you try to do something, if you want to tie some type of pre-transaction checks, it should change the user experience fundamentally. Generally, that's the wrong way to do it. The user should actually, should not even realize that something is happening on the back end. And this is again why EigenLayer becomes really powerful. So the user, you know, goes and interacts with the bridge. They, um, they link to it and they're sending a raw transaction. The interface sends that transaction to an aggregator. And that aggregator really just designed to pull all the transactions together and then broadcast that to the operator network. These are the EigenLayer operators. So your EigenLayer operator is just saying, okay, great. There's a transaction that's been broadcasted to us. It's for this bridge contract. Let's go and check the specific policy, the specific requirements for this contract that's been set by that developer team or by that ecosystem. So that requirement is stored on Ethereum. Uh, and in this case you're able to maintain a decentralized and a trust-minimized mechanism because you can actually have the owners of that policy be anyone. The ones who are supposed to be responsible for it. So the operators go and check to see if the signature, um, or to see if the transaction meets those requirements. So they pull the, the requirement and then they say, wait, we have to do some compute here. We need to make a decision of yes or no. So they'll pull the relevant information for, from on-chain when they function as a historical, uh, or an archive node and they can also, of course, pull off-chain information. So this could be anything. It could be, you know, like, uh, in this case from an Alio standpoint, it could be risk data. Uh, has the user been involved in an exploit before? Um, or are they a sanctioned entity? So in this case they go and pull that information. They make a decision and then if the transaction meets the requirements, they issue a signature. So they enforce the policy and then issue a signature. That signature is sent back to the user. So when they actually hit submit on their transaction, the signature is embedded in the transaction object. Again, the user's never realized that this happened. This should have all happened sub-second. But the user hits submit and the signature is nested in the transaction, the transaction object. So when the transaction goes through to the actual smart contract and hits a mempool, the transaction is only processed because it has this signature from the operator network. EigenLayer essentially here enables that entire structure of pre-transaction check, validation, issuance of signature. And again, sub-second latency with the ability of saying, look, the user experience should never change."
  },
  {
    "speaker": "Rob",
    "content": "So why would they do this, right? And so this, again, really becomes important. They're doing compute. And this really feeds into how we think about an overall network if we think of prerequisites. So everyone here is now incentivized to participate in a system that becomes decentralized. So information providers, of course, are supplying information and they get economies of scale. They say, hey look, we're going to get paid for this. We're providing information that's being utilized. Applications are saying we have pre-transaction rules. We have policies that we need to be enforced. So they're putting that in place. And this is where operators and re-stakers come in. Operators are responsible for enforcing that a transaction meets the requirements. And so they're going to say, hey look, we are doing a compute here. We have overhead. You know, we're running a machine. And then same, re-stakers are providing the economic security to make this all trust minimized. And so they're earning yield and they will, they'll demand yield to, um, to issue these signatures. The important part here is of course, the applications of demand for it. So there's different ways of thinking about how an operators and re-stakers make money. One is, of course, a user can have some type of fee, that, or you can have a fee that's imposed on the user. Depends on the level of compute. This could be a few cents. This could be, uh, a dollar or $2. It really just depends on the type of requirement that's being, that's needed and the type of compute that's needed. So either you have a fee that's paid and the fee is paid before the transaction is executed. So it's the first step in the entire transaction flow. Alternatively, of course, an application could subsidize the fees on behalf of their ecosystem. So you can say, hey look, we'll subsidize it."
  },
  {
    "speaker": "Rob",
    "content": "But all this creates that three-sided network. And again, going to earlier, you bootstrapped that network of operators through EigenLayer and had it that you have a distributed network as well as the ability for general user, for, for a general, uh, retail to also be able to participate in supporting that economic security through re-staking."
  }
]